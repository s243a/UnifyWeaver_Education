<!--
SPDX-License-Identifier: MIT AND CC-BY-4.0
Copyright (c) 2025 John William Creighton (s243a)
-->

# Chapter 8: Recursive CTEs

Recursive CTEs (WITH RECURSIVE) enable queries over hierarchical and graph data structures. They're essential for org charts, category trees, and path-finding queries.

## Setup

```prolog
:- use_module('src/unifyweaver/targets/sql_target').

% Employee hierarchy (for org charts)
:- sql_table(employees, [
    id-integer,
    name-text,
    manager_id-integer,
    dept-text
]).

% Category hierarchy (for nested categories)
:- sql_table(categories, [
    id-integer,
    name-text,
    parent_id-integer
]).

% Graph edges (for path finding)
:- sql_table(edges, [
    from_node-integer,
    to_node-integer,
    weight-integer
]).

% Parts hierarchy (for bill of materials)
:- sql_table(parts, [part_id-integer, part_name-text]).
:- sql_table(assemblies, [parent_part-integer, child_part-integer, quantity-integer]).
```

## How Recursive CTEs Work

A recursive CTE has two parts:
1. **Base case**: Initial rows (anchor)
2. **Recursive case**: Rows generated by joining to previous results

```
┌─────────────────┐
│   Base Case     │  → Initial seed rows
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│ Recursive Case  │  → Joins with CTE results
└────────┬────────┘
         │
         ▼ (repeats until no new rows)
┌─────────────────┐
│   Final Result  │
└─────────────────┘
```

## Recursive CTE Syntax

```prolog
compile_recursive_cte(
    CTEName,                                % Name of the recursive CTE
    [col1, col2, ...],                      % Column names
    recursive_cte(BasePred/Arity, RecursivePred/Arity),  % Base and recursive predicates
    MainPred/Arity,                         % Main query using the CTE
    SQL                                     % Output SQL
)
```

### Declaring Recursive Tables

Before using a recursive CTE, declare its schema:

```prolog
:- sql_recursive_table(CTEName, [col1-type1, col2-type2, ...]).
```

## Example 1: Organization Chart

Find all employees in an organization hierarchy:

```prolog
% Declare recursive CTE schema
:- sql_recursive_table(org_tree, [id-integer, name-text, manager_id-integer]).

% Base case: Top-level employees (no manager)
org_base(Id, Name, ManagerId) :-
    employees(Id, Name, ManagerId, _),
    sql_is_null(ManagerId).

% Recursive case: Employees whose manager is in org_tree
org_recursive(Id, Name, ManagerId) :-
    employees(Id, Name, ManagerId, _),
    org_tree(ManagerId, _, _).  % Join to CTE

% Main query: Select from the CTE
org_result(Id, Name, ManagerId) :-
    org_tree(Id, Name, ManagerId).

% Compile
?- compile_recursive_cte(
    org_tree,
    [id, name, manager_id],
    recursive_cte(org_base/3, org_recursive/3),
    org_result/3,
    SQL
).
```

Generated SQL:
```sql
WITH RECURSIVE org_tree(id, name, manager_id) AS (
    -- Base case: root employees
    SELECT id, name, manager_id
    FROM employees
    WHERE manager_id IS NULL

    UNION ALL

    -- Recursive case: employees with managers in tree
    SELECT employees.id, employees.name, employees.manager_id
    FROM employees
    INNER JOIN org_tree ON employees.manager_id = org_tree.id
)
SELECT id, name, manager_id
FROM org_tree;
```

## Example 2: Category Tree

Traverse nested categories:

```prolog
:- sql_recursive_table(cat_tree, [id-integer, name-text, parent_id-integer]).

% Base case: Root categories (no parent)
cat_base(Id, Name, ParentId) :-
    categories(Id, Name, ParentId),
    sql_is_null(ParentId).

% Recursive case: Child categories
cat_recursive(Id, Name, ParentId) :-
    categories(Id, Name, ParentId),
    cat_tree(ParentId, _, _).

% Main query
cat_result(Id, Name, ParentId) :-
    cat_tree(Id, Name, ParentId).

?- compile_recursive_cte(
    cat_tree,
    [id, name, parent_id],
    recursive_cte(cat_base/3, cat_recursive/3),
    cat_result/3,
    SQL
).
```

## Example 3: Graph Reachability

Find all nodes reachable from a starting node:

```prolog
:- sql_recursive_table(reachable, [node-integer]).

% Base case: Direct connections from node 1
reach_base(Node) :-
    edges(1, Node, _).

% Recursive case: Follow edges from reachable nodes
reach_recursive(Node) :-
    reachable(From),
    edges(From, Node, _).

% Main query
reach_result(Node) :-
    reachable(Node).

?- compile_recursive_cte(
    reachable,
    [node],
    recursive_cte(reach_base/1, reach_recursive/1),
    reach_result/1,
    SQL
).
```

Generated SQL:
```sql
WITH RECURSIVE reachable(node) AS (
    SELECT to_node FROM edges WHERE from_node = 1
    UNION ALL
    SELECT edges.to_node
    FROM reachable
    INNER JOIN edges ON edges.from_node = reachable.node
)
SELECT node FROM reachable;
```

## Example 4: Ancestors (Upward Traversal)

Find all ancestors of a specific employee:

```prolog
:- sql_recursive_table(ancestors, [emp_id-integer, ancestor_id-integer]).

% Base case: Direct manager
anc_base(EmpId, AncestorId) :-
    employees(EmpId, _, AncestorId, _),
    sql_is_not_null(AncestorId).

% Recursive case: Ancestor's manager
anc_recursive(EmpId, AncestorId) :-
    ancestors(EmpId, Mid),
    employees(Mid, _, AncestorId, _),
    sql_is_not_null(AncestorId).

% Main query: Ancestors of employee 5
anc_result(EmpId, AncestorId) :-
    ancestors(EmpId, AncestorId),
    EmpId = 5.

?- compile_recursive_cte(
    ancestors,
    [emp_id, ancestor_id],
    recursive_cte(anc_base/2, anc_recursive/2),
    anc_result/2,
    SQL
).
```

## Example 5: Bill of Materials

Find all components of a product (parts explosion):

```prolog
:- sql_recursive_table(bom, [part_id-integer, part_name-text]).

% Base case: Top-level part
bom_base(PartId, PartName) :-
    parts(PartId, PartName),
    PartId = 1.  % Starting part

% Recursive case: Component parts
bom_recursive(PartId, PartName) :-
    bom(ParentId, _),
    assemblies(ParentId, PartId, _),
    parts(PartId, PartName).

% Main query
bom_result(PartId, PartName) :-
    bom(PartId, PartName).

?- compile_recursive_cte(
    bom,
    [part_id, part_name],
    recursive_cte(bom_base/2, bom_recursive/2),
    bom_result/2,
    SQL
).
```

## Recursive CTE Options

### UNION vs UNION ALL

By default, recursive CTEs use UNION ALL. To use UNION (removes duplicates):

```prolog
compile_recursive_cte(
    cte_name,
    [cols],
    recursive_cte(base/n, recursive/n),
    main/m,
    [union_type(distinct)],  % Use UNION instead of UNION ALL
    SQL
)
```

### Generate as VIEW

Wrap the recursive CTE in a CREATE VIEW:

```prolog
compile_recursive_cte(
    org_tree,
    [id, name, manager_id],
    recursive_cte(org_base/3, org_recursive/3),
    org_result/3,
    [view_name(employee_hierarchy)],
    SQL
)
```

Generated SQL:
```sql
CREATE VIEW IF NOT EXISTS employee_hierarchy AS
WITH RECURSIVE org_tree(...) AS (...)
SELECT ...;
```

## Common Patterns

### 1. Hierarchical Depth

Track the level in the hierarchy:

```prolog
:- sql_recursive_table(org_levels, [id-integer, name-text, level-integer]).

% Base case: Level 0
level_base(Id, Name, Level) :-
    employees(Id, Name, ManagerId, _),
    sql_is_null(ManagerId),
    Level = 0.

% Recursive case: Increment level
level_recursive(Id, Name, Level) :-
    employees(Id, Name, ManagerId, _),
    org_levels(ManagerId, _, ParentLevel),
    Level = ParentLevel + 1.
```

### 2. Path Accumulation

Build paths through the hierarchy:

```prolog
:- sql_recursive_table(paths, [id-integer, path-text]).

% Base case
path_base(Id, Path) :-
    categories(Id, Name, ParentId),
    sql_is_null(ParentId),
    Path = Name.

% Recursive case: Concatenate path
path_recursive(Id, Path) :-
    categories(Id, Name, ParentId),
    paths(ParentId, ParentPath),
    Path = sql_concat([ParentPath, ' > ', Name]).
```

### 3. Cycle Prevention

For graphs with potential cycles, track visited nodes or limit depth:

```prolog
% Limit recursion depth
depth_limited(Node, Depth) :-
    edges(1, Node, _),
    Depth = 1.

depth_limited_rec(Node, Depth) :-
    depth_limited(Prev, PrevDepth),
    edges(Prev, Node, _),
    PrevDepth < 10,  % Maximum depth
    Depth = PrevDepth + 1.
```

## Performance Considerations

1. **Termination**: Ensure recursive case eventually produces no new rows
2. **Cycles**: Add depth limits or cycle detection for graph data
3. **Indexes**: Index join columns (parent_id, manager_id, etc.)
4. **Materialization**: Some databases limit recursive CTE depth

## Complete Example

```prolog
% file: recursive_cte_example.pl
:- encoding(utf8).
:- use_module('src/unifyweaver/targets/sql_target').

:- sql_table(employees, [id-integer, name-text, manager_id-integer, dept-text]).
:- sql_table(categories, [id-integer, name-text, parent_id-integer]).
:- sql_table(edges, [from_node-integer, to_node-integer, weight-integer]).

% Recursive table declarations
:- sql_recursive_table(org_tree, [id-integer, name-text, manager_id-integer]).
:- sql_recursive_table(cat_tree, [id-integer, name-text, parent_id-integer]).
:- sql_recursive_table(reachable, [node-integer]).

% Org chart
org_base(Id, Name, MgrId) :- employees(Id, Name, MgrId, _), sql_is_null(MgrId).
org_recursive(Id, Name, MgrId) :- employees(Id, Name, MgrId, _), org_tree(MgrId, _, _).
org_result(Id, Name, MgrId) :- org_tree(Id, Name, MgrId).

% Category tree
cat_base(Id, Name, PId) :- categories(Id, Name, PId), sql_is_null(PId).
cat_recursive(Id, Name, PId) :- categories(Id, Name, PId), cat_tree(PId, _, _).
cat_result(Id, Name, PId) :- cat_tree(Id, Name, PId).

% Graph reachability
reach_base(Node) :- edges(1, Node, _).
reach_recursive(Node) :- reachable(From), edges(From, Node, _).
reach_result(Node) :- reachable(Node).

test :-
    format('~n=== Recursive CTE Examples ===~n~n'),

    format('1. Organization Chart:~n'),
    compile_recursive_cte(org_tree, [id, name, manager_id],
        recursive_cte(org_base/3, org_recursive/3), org_result/3, SQL1),
    format('   ~w~n~n', [SQL1]),

    format('2. Category Tree:~n'),
    compile_recursive_cte(cat_tree, [id, name, parent_id],
        recursive_cte(cat_base/3, cat_recursive/3), cat_result/3, SQL2),
    format('   ~w~n~n', [SQL2]),

    format('3. Graph Reachability:~n'),
    compile_recursive_cte(reachable, [node],
        recursive_cte(reach_base/1, reach_recursive/1), reach_result/1, SQL3),
    format('   ~w~n~n', [SQL3]),

    format('4. With UNION (distinct):~n'),
    compile_recursive_cte(reachable, [node],
        recursive_cte(reach_base/1, reach_recursive/1), reach_result/1,
        [union_type(distinct)], SQL4),
    format('   ~w~n~n', [SQL4]).

:- initialization(test, main).
```

## Exercises

1. **Basic Hierarchy**: Create a recursive CTE to list all subordinates of a specific manager.

2. **Depth Tracking**: Modify the org chart query to include the level of each employee (CEO = 0, direct reports = 1, etc.).

3. **Path Building**: Create a query that shows the full category path for each category (e.g., "Electronics > Phones > Smartphones").

4. **Shortest Path**: Design a recursive CTE that finds paths between two nodes and tracks the total weight.

5. **Bill of Materials**: Create a query that lists all parts needed to build a product, including nested sub-assemblies.

## Summary

In this chapter, you learned:

- How recursive CTEs work (base case + recursive case)
- `sql_recursive_table/2` for declaring CTE schemas
- `compile_recursive_cte/5` for generating WITH RECURSIVE queries
- Common use cases: org charts, category trees, graph traversal
- UNION vs UNION ALL options
- Pattern techniques: depth tracking, path accumulation

## Next Chapter

In Chapter 9, we'll explore Set Operations:
- UNION and UNION ALL
- INTERSECT
- EXCEPT
- Combining multiple queries
