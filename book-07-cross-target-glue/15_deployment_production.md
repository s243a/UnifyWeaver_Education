<!--
SPDX-License-Identifier: MIT AND CC-BY-4.0
Copyright (c) 2025 John William Creighton (s243a)
-->

# Chapter 15: Production Deployment (Phase 6)

## Overview

Phase 6 makes cross-target glue production-ready with:

- Service declarations and deployment
- Security enforcement (encryption required for remote)
- Lifecycle management (start, stop, restart, graceful shutdown)
- Error resilience (retry, fallback, circuit breaker)
- Monitoring (health checks, metrics, logging, alerting)

## The Deployment Glue Module

Located at `src/unifyweaver/glue/deployment_glue.pl`:

```prolog
:- module(deployment_glue, [
    % Service management
    declare_service/2,
    service_config/2,
    undeclare_service/1,

    % Deployment methods
    declare_deploy_method/3,
    deploy_method_config/3,

    % Security
    validate_security/2,
    requires_encryption/1,
    is_local_service/1,

    % Script generation
    generate_deploy_script/3,
    generate_systemd_unit/3,
    generate_health_check_script/3,

    % Lifecycle
    start_service/2,
    stop_service/2,
    restart_service/2,
    graceful_stop/3,

    % Error handling
    declare_retry_policy/2,
    declare_fallback/2,
    declare_circuit_breaker/2,
    call_with_retry/4,
    call_with_fallback/4,
    call_with_circuit_breaker/4,
    protected_call/4,

    % Monitoring
    declare_health_check/2,
    declare_metrics/2,
    declare_logging/2,
    declare_alert/3,
    record_metric/3,
    log_event/4,
    trigger_alert/3
]).
```

## Service Declarations

### Declaring a Service

```prolog
declare_service(Name, Options).
```

**Options:**
| Option | Values | Description |
|--------|--------|-------------|
| `host(H)` | String | Hostname or IP |
| `port(P)` | Integer | Port number |
| `target(T)` | Atom | Target language (go, python, rust) |
| `transport(T)` | `http`, `https`, `ssh` | Communication protocol |

**Example:**
```prolog
% Declare a production API service
declare_service(api_service, [
    host('api.example.com'),
    port(8080),
    target(go),
    transport(https)
]).

% Declare a local development service
declare_service(dev_service, [
    host(localhost),
    port(3000),
    target(python),
    transport(http)
]).
```

### Querying Services

```prolog
?- service_config(api_service, Config).
Config = [host('api.example.com'), port(8080), target(go), transport(https)].
```

## Security Enforcement

**Critical**: Remote services MUST use encrypted transport. This is non-negotiable.

### Security Validation

```prolog
% This succeeds - local HTTP is allowed
declare_service(local_svc, [host(localhost), port(8080), transport(http)]),
validate_security(local_svc, []).  % âœ“ Passes

% This FAILS - remote HTTP is blocked
declare_service(remote_svc, [host('api.example.com'), port(8080), transport(http)]),
validate_security(remote_svc, []).  % âœ— Fails - encryption required

% This succeeds - remote HTTPS is allowed
declare_service(secure_svc, [host('api.example.com'), port(443), transport(https)]),
validate_security(secure_svc, []).  % âœ“ Passes
```

### Checking Encryption Requirements

```prolog
?- requires_encryption(remote_svc).
true.

?- requires_encryption(local_svc).
false.

?- is_local_service(local_svc).
true.
```

## Deployment Methods

### SSH Deployment

```prolog
declare_deploy_method(api_service, ssh, [
    user(deploy),
    remote_dir('/opt/api_service'),
    key_file('~/.ssh/deploy_key')
]).
```

### Generating Deploy Scripts

```prolog
?- generate_deploy_script(api_service, [], Script).
```

Generated:
```bash
#!/bin/bash
# Deployment script for api_service
# Generated by UnifyWeaver deployment_glue

set -euo pipefail

SERVICE="api_service"
HOST="api.example.com"
USER="deploy"
REMOTE_DIR="/opt/api_service"
PORT="8080"

echo "=== Deploying ${SERVICE} to ${HOST} ==="

# Check SSH agent
if ! ssh-add -l &>/dev/null; then
    echo "Warning: SSH agent not running or no keys loaded"
fi

# Check connectivity
ssh -o ConnectTimeout=10 "${USER}@${HOST}" "echo ok" >/dev/null 2>&1

# Create remote directory
ssh "${USER}@${HOST}" "mkdir -p ${REMOTE_DIR}"

# Sync sources
rsync -avz --delete \
    --exclude "*.pyc" \
    --exclude "__pycache__" \
    --exclude ".git" \
    ./ "${USER}@${HOST}:${REMOTE_DIR}/"

# Restart service
ssh "${USER}@${HOST}" "systemctl restart ${SERVICE}"

echo "=== Deployment complete ==="
```

### Generating Systemd Units

```prolog
?- generate_systemd_unit(api_service, [
    description('API Service'),
    working_dir('/opt/api_service'),
    exec_start('/opt/api_service/server'),
    restart(always)
], Unit).
```

Generated:
```ini
[Unit]
Description=API Service
After=network.target

[Service]
Type=simple
User=deploy
WorkingDirectory=/opt/api_service
ExecStart=/opt/api_service/server
Restart=always
RestartSec=5
StandardOutput=journal
StandardError=journal

[Install]
WantedBy=multi-user.target
```

## Lifecycle Management

### Starting and Stopping Services

```prolog
% Start a service
start_service(api_service, Result).

% Stop a service
stop_service(api_service, Result).

% Restart a service
restart_service(api_service, Result).
```

### Graceful Shutdown

```prolog
% Graceful stop with connection draining
graceful_stop(api_service, [
    timeout(30),
    drain_connections(true)
], Result).
```

### Lifecycle Hooks

```prolog
% Register hooks for deployment events
declare_lifecycle_hook(api_service, pre_shutdown, [
    drain_connections,
    save_state
]).

declare_lifecycle_hook(api_service, post_deploy, [
    health_check,
    warm_cache
]).
```

## Multi-Host Deployment

### Declaring Multiple Hosts

```prolog
declare_service_hosts(api_service, [
    host(web1, 'web1.example.com', [zone(us_east)]),
    host(web2, 'web2.example.com', [zone(us_west)]),
    host(web3, 'web3.example.com', [zone(eu_west)])
]).
```

### Deploying to All Hosts

```prolog
% Deploy to all configured hosts
deploy_to_all_hosts(api_service, Results).
```

## Rollback Support

### Storing Rollback Points

```prolog
% Store current deployment hash for rollback
store_rollback_hash(api_service, 'abc123def456').
```

### Rolling Back

```prolog
% Rollback to previous version
rollback_service(api_service, Result).

% Deploy with automatic rollback on failure
deploy_with_rollback(api_service, Result).
```

## Error Handling

### Retry Policies

```prolog
declare_retry_policy(api_calls, [
    max_retries(3),
    retry_delay(exponential(1000, 2, 30000)),  % 1s, 2s, 4s... max 30s
    retry_on([connection_error, timeout])
]).

% Use the policy
call_with_retry(api_calls, my_api_call(Args), Result, Status).
```

### Fallback Mechanisms

```prolog
% Fallback to default value
declare_fallback(cache_lookup, [
    strategy(default_value),
    default_value(not_found)
]).

% Fallback to backup service
declare_fallback(primary_api, [
    strategy(fallback_service),
    fallback(backup_api)
]).

% Use fallback
call_with_fallback(cache_lookup, get_cached(Key), Result, Status).
```

### Circuit Breaker

```prolog
declare_circuit_breaker(external_api, [
    failure_threshold(5),      % Open after 5 failures
    reset_timeout(60),         % Try again after 60 seconds
    half_open_max(2)           % Allow 2 test requests in half-open
]).

% Check state
?- circuit_state(external_api, State).
State = closed.

% Record failures
record_circuit_failure(external_api),
record_circuit_failure(external_api),
% ... after 5 failures ...

?- circuit_state(external_api, State).
State = open.

% Reset manually
reset_circuit_breaker(external_api).
```

### Combined Protection

```prolog
% Apply all protections: circuit breaker â†’ timeout â†’ retry â†’ fallback
protected_call(api_service, my_operation(Args), Result, Status).
```

## Monitoring

### Health Checks

```prolog
declare_health_check(api_service, [
    endpoint('/health'),
    interval(30),              % Check every 30 seconds
    timeout(5),                % 5 second timeout
    healthy_threshold(2),      % 2 successes = healthy
    unhealthy_threshold(3)     % 3 failures = unhealthy
]).

% Generate health check script
generate_health_check_script(api_service, [], Script).
```

Generated:
```bash
#!/bin/bash
HOST="api.example.com"
PORT="8080"
ENDPOINT="/health"
PROTOCOL="https"

URL="${PROTOCOL}://${HOST}:${PORT}${ENDPOINT}"

for i in $(seq 1 3); do
    if curl -sf --max-time 5 "$URL" >/dev/null; then
        echo "OK: api_service is healthy"
        exit 0
    fi
    sleep 2
done

echo "CRITICAL: api_service health check failed"
exit 2
```

### Metrics Collection

```prolog
declare_metrics(api_service, [
    prefix('unifyweaver_api'),
    export_format(prometheus)
]).

% Record metrics
record_metric(api_service, request_count, 1),
record_metric(api_service, latency, 45.5),
record_metric(api_service, error_count, 0).

% Get all metrics
?- get_metrics(api_service, Metrics).
Metrics = [metric(request_count, 1, Timestamp), ...].

% Export in Prometheus format
?- generate_prometheus_metrics(api_service, Output).
Output = 'unifyweaver_api_request_count 1
unifyweaver_api_latency 45.5
unifyweaver_api_error_count 0'.
```

### Structured Logging

```prolog
declare_logging(api_service, [
    level(info),
    format(json),
    output(stdout)
]).

% Log events with metadata
log_event(api_service, info, 'Request processed', [
    method('GET'),
    path('/api/users'),
    duration_ms(42)
]).
```

Output:
```json
{"timestamp":"2025-01-15T10:30:00Z","service":"api_service","level":"info","message":"Request processed","method":"GET","path":"/api/users","duration_ms":42}
```

### Alerting

```prolog
declare_alert(api_service, high_error_rate, [
    condition(error_rate > 0.05),
    severity(critical),
    cooldown(300),              % 5 minute cooldown
    notify([slack, pagerduty])
]).

% Trigger an alert
trigger_alert(api_service, high_error_rate, [
    error_rate(0.08),
    timestamp('2025-01-15T10:30:00Z')
]).

% Check active alerts
?- check_alerts(api_service, Alerts).
Alerts = [high_error_rate].
```

## Complete Deployment Example

Here's a complete example deploying a compiled Prolog predicate as a production service:

```prolog
% production_deploy.pl
:- use_module('src/unifyweaver/glue/deployment_glue').
:- use_module('src/unifyweaver/targets/go_target').
:- use_module('src/unifyweaver/glue/network_glue').

%% Step 1: Define the service logic in Prolog
:- module(analytics, [aggregate_metrics/2]).

aggregate_metrics(Input, Output) :-
    % Your analytics logic here
    compute_aggregates(Input, Output).

%% Step 2: Compile to Go for production performance
compile_analytics :-
    compile_predicate_to_go(aggregate_metrics/2, [
        parallel(8),
        format(json)
    ], GoCode),
    open('analytics_server.go', write, S),
    write(S, GoCode),
    close(S).

%% Step 3: Declare the production service
setup_production :-
    % Declare the service
    declare_service(analytics_api, [
        host('analytics.example.com'),
        port(8080),
        target(go),
        transport(https)
    ]),

    % Configure SSH deployment
    declare_deploy_method(analytics_api, ssh, [
        user(deploy),
        remote_dir('/opt/analytics')
    ]),

    % Configure error handling
    declare_retry_policy(analytics_api, [
        max_retries(3),
        retry_delay(exponential(1000, 2, 10000))
    ]),

    declare_circuit_breaker(analytics_api, [
        failure_threshold(5),
        reset_timeout(60)
    ]),

    % Configure monitoring
    declare_health_check(analytics_api, [
        endpoint('/health'),
        interval(30)
    ]),

    declare_metrics(analytics_api, [
        prefix('analytics'),
        export_format(prometheus)
    ]),

    declare_logging(analytics_api, [
        level(info),
        format(json)
    ]),

    declare_alert(analytics_api, high_latency, [
        condition(p99_latency > 1000),
        severity(warning),
        notify([slack])
    ]).

%% Step 4: Deploy
deploy :-
    % Validate security (will fail if HTTP to remote)
    validate_security(analytics_api, []),

    % Generate and execute deployment
    generate_deploy_script(analytics_api, [], Script),

    % Write and execute
    open('deploy.sh', write, S),
    write(S, Script),
    close(S),
    shell('chmod +x deploy.sh && ./deploy.sh').
```

## Chapter Summary

Phase 6 provides production-ready infrastructure:

- **Service declarations** define what to deploy and where
- **Security validation** enforces encryption for remote services
- **Deployment scripts** automate SSH, systemd, and health checks
- **Lifecycle management** handles start/stop/restart gracefully
- **Error resilience** with retry, fallback, and circuit breaker
- **Monitoring** via health checks, metrics, logging, and alerting

## Exercises

1. **Service setup**: Declare a Python service running on localhost:5000 with HTTP transport. Verify it passes security validation.

2. **Security test**: Try to declare a remote service with HTTP transport. What happens when you call `validate_security/2`?

3. **Circuit breaker**: Configure a circuit breaker that opens after 3 failures and resets after 30 seconds. Simulate failures and verify state transitions.

4. **Metrics**: Set up Prometheus metrics for a service. Record 100 requests and export the metrics.

5. **Complete deployment**: Write a complete deployment configuration for a Go service including SSH deployment, health checks, and alerting.

## Advanced Example: Fault-Tolerant Pipeline

This example demonstrates deploying a fault-tolerant multi-stage pipeline with full production features.

### Step 1: Define the Pipeline Predicates

```prolog
% fault_tolerant_pipeline.pl
:- module(ft_pipeline, [
    ingest/2,
    transform/2,
    store/2
]).

% Ingest stage - reads from external source
ingest(Source, Data) :-
    fetch_external(Source, Raw),
    validate_input(Raw, Data).

% Transform stage - applies business logic
transform(Data, Result) :-
    apply_rules(Data, Intermediate),
    enrich(Intermediate, Result).

% Store stage - persists to database
store(Result, Id) :-
    serialize(Result, Payload),
    insert_db(Payload, Id).
```

### Step 2: Compile and Declare Services

```prolog
setup_ft_pipeline :-
    % Compile each stage to optimal target
    compile_predicate_to_python(ingest/2, [format(json)], _),
    compile_predicate_to_go(transform/2, [parallel(4)], _),
    compile_predicate_to_rust(store/2, [], _),

    % Declare services with fault tolerance
    declare_service(ingest_svc, [
        host('ingest.internal'),
        port(8081),
        target(python),
        transport(https)
    ]),

    declare_service(transform_svc, [
        host('transform.internal'),
        port(8082),
        target(go),
        transport(https)
    ]),

    declare_service(store_svc, [
        host('store.internal'),
        port(8083),
        target(rust),
        transport(https)
    ]),

    % Configure fault tolerance for each
    configure_fault_tolerance(ingest_svc),
    configure_fault_tolerance(transform_svc),
    configure_fault_tolerance(store_svc).

configure_fault_tolerance(Service) :-
    declare_retry_policy(Service, [
        max_retries(3),
        retry_delay(exponential(500, 2, 5000))
    ]),

    declare_circuit_breaker(Service, [
        failure_threshold(5),
        reset_timeout(30)
    ]),

    declare_fallback(Service, [
        strategy(cached_result),
        cache_ttl(300)
    ]),

    declare_health_check(Service, [
        endpoint('/health'),
        interval(10),
        unhealthy_threshold(3)
    ]),

    declare_alert(Service, service_down, [
        condition(health_status = unhealthy),
        severity(critical),
        notify([pagerduty])
    ]).
```

### Step 3: Execute with Protection

```prolog
run_pipeline(Input, Output) :-
    % Each call is protected with retry + circuit breaker + fallback
    protected_call(ingest_svc, ingest(Input, Data), Data, Status1),
    Status1 = success,

    protected_call(transform_svc, transform(Data, Result), Result, Status2),
    Status2 = success,

    protected_call(store_svc, store(Result, Id), Id, Status3),
    Status3 = success,

    Output = stored(Id).
```

### Modification Exercise

**Task**: Add a dead-letter queue for failed records.

**What to do**:
1. Declare a `dead_letter_svc` service
2. Modify `run_pipeline/2` to catch failures and route to dead letter
3. Add alerting when dead letter queue grows too large

**Hints**:
- Use fallback strategy to route to dead letter on failure
- Track dead letter count as a metric
- Alert when `dead_letter_count > 100`

---

## Navigation

**â†** [Previous: Chapter 14: Case Studies](14_case_studies) | [ğŸ“– Book 7: Cross-Target Glue](./) | [Next: Chapter 16: Cloud & Enterprise (Phase 7) â†’](16_cloud_enterprise)
