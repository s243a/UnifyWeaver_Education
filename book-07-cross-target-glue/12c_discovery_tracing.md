# Chapter 12c: Service Discovery and Distributed Tracing

This chapter covers the final phases of the client-server architecture: runtime service discovery (Phase 7) and distributed tracing for observability (Phase 8).

## Part 1: Service Discovery (Phase 7)

Service discovery enables services to find and connect to each other dynamically at runtime, without hardcoded addresses.

### Discovery Backends

UnifyWeaver supports multiple service discovery backends:

| Backend | Description | Best For |
|---------|-------------|----------|
| `consul` | HashiCorp Consul | Production multi-service |
| `etcd` | CoreOS etcd | Kubernetes native |
| `dns` | DNS-based discovery | Simple deployments |
| `kubernetes` | K8s native discovery | K8s environments |

### Health Check Types

| Type | Format | Description |
|------|--------|-------------|
| HTTP | `http(Path, IntervalMs)` | HTTP endpoint check |
| TCP | `tcp(Port, IntervalMs)` | TCP port check |

### Service Discovery Options

| Option | Values | Description |
|--------|--------|-------------|
| `discovery_enabled(Bool)` | `true`, `false` | Enable discovery |
| `discovery_backend(Backend)` | `consul`, `etcd`, `dns`, `kubernetes` | Discovery system |
| `health_check(Config)` | `http(Path, Interval)`, `tcp(Port, Interval)` | Health check configuration |
| `discovery_ttl(Seconds)` | Integer | Registration TTL |
| `discovery_tags(Tags)` | List of atoms | Service tags for filtering |

### Defining a Discoverable Service

```prolog
service(user_api, [
    discovery_enabled(true),
    discovery_backend(consul),
    health_check(http('/health', 30000)),
    discovery_ttl(60),
    discovery_tags([production, v2, us_east]),
    transport(http(8080))
], [
    receive(Request),
    state_get(users, Users),
    respond(Response)
]).
```

### Service Discovery Architecture

```
┌─────────────────────────────────────────────────────────────┐
│                    Service Discovery                         │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│   ┌──────────────┐     Register     ┌──────────────────┐   │
│   │   Service    │ ───────────────► │   Discovery      │   │
│   │   Instance   │                  │   Backend        │   │
│   │              │ ◄─────────────── │   (Consul/etcd)  │   │
│   └──────────────┘     Heartbeat    └──────────────────┘   │
│          ▲                                   │              │
│          │                                   │              │
│   Health Check                          Query │              │
│          │                                   ▼              │
│   ┌──────────────┐                  ┌──────────────────┐   │
│   │   Health     │                  │   Client         │   │
│   │   Checker    │                  │   Service        │   │
│   └──────────────┘                  └──────────────────┘   │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

### Python Service Discovery Implementation

```python
# Generated by UnifyWeaver - Service Discovery
import json
import threading
import time
import urllib.request
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import Dict, List, Optional, Any, Callable
from datetime import datetime, timedelta

class HealthStatus(Enum):
    HEALTHY = "healthy"
    UNHEALTHY = "unhealthy"
    UNKNOWN = "unknown"

@dataclass
class ServiceInstance:
    """Represents a service instance in the registry."""
    service_id: str
    service_name: str
    host: str
    port: int
    tags: List[str] = field(default_factory=list)
    metadata: Dict[str, str] = field(default_factory=dict)
    health_status: HealthStatus = HealthStatus.UNKNOWN
    last_heartbeat: datetime = field(default_factory=datetime.now)

class ServiceRegistry(ABC):
    """Abstract base class for service registries."""

    @abstractmethod
    def register(self, instance: ServiceInstance) -> bool:
        """Register a service instance."""
        pass

    @abstractmethod
    def deregister(self, service_id: str) -> bool:
        """Deregister a service instance."""
        pass

    @abstractmethod
    def discover(self, service_name: str, tags: List[str] = None) -> List[ServiceInstance]:
        """Discover service instances by name and optional tags."""
        pass

    @abstractmethod
    def heartbeat(self, service_id: str) -> bool:
        """Send heartbeat for a service instance."""
        pass

class LocalRegistry(ServiceRegistry):
    """In-memory service registry for local/development use."""

    def __init__(self, ttl_seconds: int = 60):
        self._services: Dict[str, ServiceInstance] = {}
        self._lock = threading.RLock()
        self._ttl = timedelta(seconds=ttl_seconds)

    def register(self, instance: ServiceInstance) -> bool:
        with self._lock:
            instance.last_heartbeat = datetime.now()
            self._services[instance.service_id] = instance
            return True

    def deregister(self, service_id: str) -> bool:
        with self._lock:
            if service_id in self._services:
                del self._services[service_id]
                return True
            return False

    def discover(self, service_name: str, tags: List[str] = None) -> List[ServiceInstance]:
        with self._lock:
            self._cleanup_expired()
            results = []
            for instance in self._services.values():
                if instance.service_name != service_name:
                    continue
                if instance.health_status != HealthStatus.HEALTHY:
                    continue
                if tags and not all(t in instance.tags for t in tags):
                    continue
                results.append(instance)
            return results

    def heartbeat(self, service_id: str) -> bool:
        with self._lock:
            if service_id in self._services:
                self._services[service_id].last_heartbeat = datetime.now()
                return True
            return False

    def _cleanup_expired(self) -> None:
        """Remove expired service instances."""
        now = datetime.now()
        expired = [
            sid for sid, inst in self._services.items()
            if now - inst.last_heartbeat > self._ttl
        ]
        for sid in expired:
            del self._services[sid]

class ConsulRegistry(ServiceRegistry):
    """Consul-based service registry."""

    def __init__(self, consul_url: str = "http://localhost:8500"):
        self._consul_url = consul_url
        self._session = None

    def register(self, instance: ServiceInstance) -> bool:
        """Register service with Consul."""
        payload = {
            "ID": instance.service_id,
            "Name": instance.service_name,
            "Address": instance.host,
            "Port": instance.port,
            "Tags": instance.tags,
            "Meta": instance.metadata,
            "Check": {
                "HTTP": f"http://{instance.host}:{instance.port}/health",
                "Interval": "30s"
            }
        }

        try:
            url = f"{self._consul_url}/v1/agent/service/register"
            data = json.dumps(payload).encode('utf-8')
            request = urllib.request.Request(
                url, data=data,
                headers={'Content-Type': 'application/json'},
                method='PUT'
            )
            with urllib.request.urlopen(request, timeout=10) as response:
                return response.status == 200
        except Exception as e:
            print(f"Failed to register with Consul: {e}")
            return False

    def deregister(self, service_id: str) -> bool:
        """Deregister service from Consul."""
        try:
            url = f"{self._consul_url}/v1/agent/service/deregister/{service_id}"
            request = urllib.request.Request(url, method='PUT')
            with urllib.request.urlopen(request, timeout=10) as response:
                return response.status == 200
        except Exception:
            return False

    def discover(self, service_name: str, tags: List[str] = None) -> List[ServiceInstance]:
        """Query Consul for healthy service instances."""
        try:
            url = f"{self._consul_url}/v1/health/service/{service_name}?passing=true"
            if tags:
                for tag in tags:
                    url += f"&tag={tag}"

            with urllib.request.urlopen(url, timeout=10) as response:
                data = json.loads(response.read().decode('utf-8'))

            return [
                ServiceInstance(
                    service_id=entry['Service']['ID'],
                    service_name=entry['Service']['Service'],
                    host=entry['Service']['Address'],
                    port=entry['Service']['Port'],
                    tags=entry['Service'].get('Tags', []),
                    metadata=entry['Service'].get('Meta', {}),
                    health_status=HealthStatus.HEALTHY
                )
                for entry in data
            ]
        except Exception as e:
            print(f"Failed to discover services: {e}")
            return []

    def heartbeat(self, service_id: str) -> bool:
        """Consul uses health checks instead of heartbeats."""
        return True

class HealthChecker:
    """Performs health checks on service endpoints."""

    def __init__(self, check_interval_ms: int = 30000):
        self._interval = check_interval_ms / 1000.0
        self._checks: Dict[str, Callable[[], bool]] = {}
        self._status: Dict[str, HealthStatus] = {}
        self._running = False
        self._thread = None
        self._lock = threading.RLock()

    def add_http_check(self, name: str, url: str, timeout: float = 5.0) -> None:
        """Add an HTTP health check."""
        def check():
            try:
                with urllib.request.urlopen(url, timeout=timeout) as response:
                    return 200 <= response.status < 300
            except Exception:
                return False

        with self._lock:
            self._checks[name] = check
            self._status[name] = HealthStatus.UNKNOWN

    def add_tcp_check(self, name: str, host: str, port: int, timeout: float = 5.0) -> None:
        """Add a TCP port health check."""
        import socket

        def check():
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(timeout)
                result = sock.connect_ex((host, port))
                sock.close()
                return result == 0
            except Exception:
                return False

        with self._lock:
            self._checks[name] = check
            self._status[name] = HealthStatus.UNKNOWN

    def get_status(self, name: str) -> HealthStatus:
        """Get the current health status of a check."""
        with self._lock:
            return self._status.get(name, HealthStatus.UNKNOWN)

    def start(self) -> None:
        """Start the health checker background thread."""
        self._running = True
        self._thread = threading.Thread(target=self._run_checks, daemon=True)
        self._thread.start()

    def stop(self) -> None:
        """Stop the health checker."""
        self._running = False
        if self._thread:
            self._thread.join(timeout=5.0)

    def _run_checks(self) -> None:
        """Background thread that runs health checks."""
        while self._running:
            with self._lock:
                for name, check in self._checks.items():
                    try:
                        result = check()
                        self._status[name] = (
                            HealthStatus.HEALTHY if result
                            else HealthStatus.UNHEALTHY
                        )
                    except Exception:
                        self._status[name] = HealthStatus.UNHEALTHY

            time.sleep(self._interval)

# Global instances
REGISTRY = LocalRegistry(ttl_seconds=60)
HEALTH_CHECKER = HealthChecker(check_interval_ms=30000)
```

### Go Service Discovery Implementation

```go
// Generated by UnifyWeaver - Service Discovery
package main

import (
    "bytes"
    "encoding/json"
    "fmt"
    "io"
    "net"
    "net/http"
    "sync"
    "time"
)

// HealthStatus represents the health state of a service
type HealthStatus int

const (
    HealthUnknown HealthStatus = iota
    HealthHealthy
    HealthUnhealthy
)

// ServiceInstance represents a registered service
type ServiceInstance struct {
    ServiceID    string            `json:"id"`
    ServiceName  string            `json:"name"`
    Host         string            `json:"host"`
    Port         int               `json:"port"`
    Tags         []string          `json:"tags"`
    Metadata     map[string]string `json:"metadata"`
    Health       HealthStatus      `json:"-"`
    LastHeartbeat time.Time        `json:"-"`
}

// ServiceRegistry interface for service discovery backends
type ServiceRegistry interface {
    Register(instance *ServiceInstance) error
    Deregister(serviceID string) error
    Discover(serviceName string, tags []string) ([]*ServiceInstance, error)
    Heartbeat(serviceID string) error
}

// LocalRegistry is an in-memory registry for development
type LocalRegistry struct {
    services map[string]*ServiceInstance
    mu       sync.RWMutex
    ttl      time.Duration
}

// NewLocalRegistry creates a new local registry
func NewLocalRegistry(ttl time.Duration) *LocalRegistry {
    registry := &LocalRegistry{
        services: make(map[string]*ServiceInstance),
        ttl:      ttl,
    }
    go registry.cleanupLoop()
    return registry
}

func (r *LocalRegistry) Register(instance *ServiceInstance) error {
    r.mu.Lock()
    defer r.mu.Unlock()

    instance.LastHeartbeat = time.Now()
    instance.Health = HealthHealthy
    r.services[instance.ServiceID] = instance
    return nil
}

func (r *LocalRegistry) Deregister(serviceID string) error {
    r.mu.Lock()
    defer r.mu.Unlock()

    delete(r.services, serviceID)
    return nil
}

func (r *LocalRegistry) Discover(serviceName string, tags []string) ([]*ServiceInstance, error) {
    r.mu.RLock()
    defer r.mu.RUnlock()

    var results []*ServiceInstance
    for _, instance := range r.services {
        if instance.ServiceName != serviceName {
            continue
        }
        if instance.Health != HealthHealthy {
            continue
        }
        if !r.hasAllTags(instance, tags) {
            continue
        }
        results = append(results, instance)
    }
    return results, nil
}

func (r *LocalRegistry) Heartbeat(serviceID string) error {
    r.mu.Lock()
    defer r.mu.Unlock()

    if instance, ok := r.services[serviceID]; ok {
        instance.LastHeartbeat = time.Now()
        instance.Health = HealthHealthy
        return nil
    }
    return fmt.Errorf("service not found: %s", serviceID)
}

func (r *LocalRegistry) hasAllTags(instance *ServiceInstance, tags []string) bool {
    if len(tags) == 0 {
        return true
    }
    tagSet := make(map[string]bool)
    for _, t := range instance.Tags {
        tagSet[t] = true
    }
    for _, t := range tags {
        if !tagSet[t] {
            return false
        }
    }
    return true
}

func (r *LocalRegistry) cleanupLoop() {
    ticker := time.NewTicker(r.ttl / 2)
    defer ticker.Stop()

    for range ticker.C {
        r.cleanup()
    }
}

func (r *LocalRegistry) cleanup() {
    r.mu.Lock()
    defer r.mu.Unlock()

    now := time.Now()
    for id, instance := range r.services {
        if now.Sub(instance.LastHeartbeat) > r.ttl {
            delete(r.services, id)
        }
    }
}

// ConsulRegistry integrates with HashiCorp Consul
type ConsulRegistry struct {
    consulURL string
    client    *http.Client
}

// NewConsulRegistry creates a new Consul registry
func NewConsulRegistry(consulURL string) *ConsulRegistry {
    return &ConsulRegistry{
        consulURL: consulURL,
        client:    &http.Client{Timeout: 10 * time.Second},
    }
}

func (r *ConsulRegistry) Register(instance *ServiceInstance) error {
    payload := map[string]interface{}{
        "ID":      instance.ServiceID,
        "Name":    instance.ServiceName,
        "Address": instance.Host,
        "Port":    instance.Port,
        "Tags":    instance.Tags,
        "Meta":    instance.Metadata,
        "Check": map[string]interface{}{
            "HTTP":     fmt.Sprintf("http://%s:%d/health", instance.Host, instance.Port),
            "Interval": "30s",
        },
    }

    data, err := json.Marshal(payload)
    if err != nil {
        return err
    }

    url := fmt.Sprintf("%s/v1/agent/service/register", r.consulURL)
    req, err := http.NewRequest("PUT", url, bytes.NewReader(data))
    if err != nil {
        return err
    }
    req.Header.Set("Content-Type", "application/json")

    resp, err := r.client.Do(req)
    if err != nil {
        return err
    }
    defer resp.Body.Close()

    if resp.StatusCode != http.StatusOK {
        return fmt.Errorf("consul register failed: %d", resp.StatusCode)
    }

    return nil
}

func (r *ConsulRegistry) Deregister(serviceID string) error {
    url := fmt.Sprintf("%s/v1/agent/service/deregister/%s", r.consulURL, serviceID)
    req, err := http.NewRequest("PUT", url, nil)
    if err != nil {
        return err
    }

    resp, err := r.client.Do(req)
    if err != nil {
        return err
    }
    defer resp.Body.Close()

    return nil
}

func (r *ConsulRegistry) Discover(serviceName string, tags []string) ([]*ServiceInstance, error) {
    url := fmt.Sprintf("%s/v1/health/service/%s?passing=true", r.consulURL, serviceName)
    for _, tag := range tags {
        url += "&tag=" + tag
    }

    resp, err := r.client.Get(url)
    if err != nil {
        return nil, err
    }
    defer resp.Body.Close()

    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return nil, err
    }

    var entries []struct {
        Service struct {
            ID      string            `json:"ID"`
            Service string            `json:"Service"`
            Address string            `json:"Address"`
            Port    int               `json:"Port"`
            Tags    []string          `json:"Tags"`
            Meta    map[string]string `json:"Meta"`
        } `json:"Service"`
    }

    if err := json.Unmarshal(body, &entries); err != nil {
        return nil, err
    }

    var results []*ServiceInstance
    for _, entry := range entries {
        results = append(results, &ServiceInstance{
            ServiceID:   entry.Service.ID,
            ServiceName: entry.Service.Service,
            Host:        entry.Service.Address,
            Port:        entry.Service.Port,
            Tags:        entry.Service.Tags,
            Metadata:    entry.Service.Meta,
            Health:      HealthHealthy,
        })
    }

    return results, nil
}

func (r *ConsulRegistry) Heartbeat(serviceID string) error {
    // Consul uses health checks, not explicit heartbeats
    return nil
}

// HealthChecker performs periodic health checks
type HealthChecker struct {
    interval time.Duration
    checks   map[string]func() bool
    status   map[string]HealthStatus
    mu       sync.RWMutex
    stopCh   chan struct{}
}

// NewHealthChecker creates a new health checker
func NewHealthChecker(interval time.Duration) *HealthChecker {
    return &HealthChecker{
        interval: interval,
        checks:   make(map[string]func() bool),
        status:   make(map[string]HealthStatus),
        stopCh:   make(chan struct{}),
    }
}

// AddHTTPCheck adds an HTTP health check
func (h *HealthChecker) AddHTTPCheck(name, url string, timeout time.Duration) {
    h.mu.Lock()
    defer h.mu.Unlock()

    client := &http.Client{Timeout: timeout}
    h.checks[name] = func() bool {
        resp, err := client.Get(url)
        if err != nil {
            return false
        }
        defer resp.Body.Close()
        return resp.StatusCode >= 200 && resp.StatusCode < 300
    }
    h.status[name] = HealthUnknown
}

// AddTCPCheck adds a TCP port health check
func (h *HealthChecker) AddTCPCheck(name, host string, port int, timeout time.Duration) {
    h.mu.Lock()
    defer h.mu.Unlock()

    address := fmt.Sprintf("%s:%d", host, port)
    h.checks[name] = func() bool {
        conn, err := net.DialTimeout("tcp", address, timeout)
        if err != nil {
            return false
        }
        conn.Close()
        return true
    }
    h.status[name] = HealthUnknown
}

// Start begins the health check loop
func (h *HealthChecker) Start() {
    go h.runChecks()
}

// Stop stops the health checker
func (h *HealthChecker) Stop() {
    close(h.stopCh)
}

// GetStatus returns the health status of a check
func (h *HealthChecker) GetStatus(name string) HealthStatus {
    h.mu.RLock()
    defer h.mu.RUnlock()
    return h.status[name]
}

func (h *HealthChecker) runChecks() {
    ticker := time.NewTicker(h.interval)
    defer ticker.Stop()

    for {
        select {
        case <-h.stopCh:
            return
        case <-ticker.C:
            h.mu.Lock()
            for name, check := range h.checks {
                if check() {
                    h.status[name] = HealthHealthy
                } else {
                    h.status[name] = HealthUnhealthy
                }
            }
            h.mu.Unlock()
        }
    }
}

// startHeartbeat begins sending heartbeats to the registry
func startHeartbeat(registry ServiceRegistry, serviceID string, interval time.Duration) chan struct{} {
    stopCh := make(chan struct{})

    go func() {
        ticker := time.NewTicker(interval)
        defer ticker.Stop()

        for {
            select {
            case <-stopCh:
                return
            case <-ticker.C:
                registry.Heartbeat(serviceID)
            }
        }
    }()

    return stopCh
}
```

### Rust Service Discovery Implementation

```rust
// Generated by UnifyWeaver - Service Discovery
use lazy_static::lazy_static;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::sync::{Arc, RwLock};
use std::time::{Duration, Instant};

#[derive(Clone, Copy, Debug, PartialEq, Serialize, Deserialize)]
pub enum HealthStatus {
    Healthy,
    Unhealthy,
    Unknown,
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct ServiceInstance {
    pub service_id: String,
    pub service_name: String,
    pub host: String,
    pub port: u16,
    pub tags: Vec<String>,
    pub metadata: HashMap<String, String>,
    #[serde(skip)]
    pub health: HealthStatus,
    #[serde(skip)]
    pub last_heartbeat: Option<Instant>,
}

impl ServiceInstance {
    pub fn new(
        service_id: &str,
        service_name: &str,
        host: &str,
        port: u16,
    ) -> Self {
        ServiceInstance {
            service_id: service_id.to_string(),
            service_name: service_name.to_string(),
            host: host.to_string(),
            port,
            tags: Vec::new(),
            metadata: HashMap::new(),
            health: HealthStatus::Unknown,
            last_heartbeat: None,
        }
    }

    pub fn with_tags(mut self, tags: Vec<&str>) -> Self {
        self.tags = tags.into_iter().map(String::from).collect();
        self
    }
}

pub trait ServiceRegistry: Send + Sync {
    fn register(&self, instance: ServiceInstance) -> Result<(), Box<dyn std::error::Error>>;
    fn deregister(&self, service_id: &str) -> Result<(), Box<dyn std::error::Error>>;
    fn discover(
        &self,
        service_name: &str,
        tags: Option<&[&str]>,
    ) -> Result<Vec<ServiceInstance>, Box<dyn std::error::Error>>;
    fn heartbeat(&self, service_id: &str) -> Result<(), Box<dyn std::error::Error>>;
}

pub struct LocalRegistry {
    services: RwLock<HashMap<String, ServiceInstance>>,
    ttl: Duration,
}

impl LocalRegistry {
    pub fn new(ttl: Duration) -> Self {
        LocalRegistry {
            services: RwLock::new(HashMap::new()),
            ttl,
        }
    }

    fn cleanup_expired(&self) {
        let mut services = self.services.write().unwrap();
        let now = Instant::now();

        services.retain(|_, instance| {
            instance
                .last_heartbeat
                .map(|t| now.duration_since(t) < self.ttl)
                .unwrap_or(false)
        });
    }

    fn has_all_tags(instance: &ServiceInstance, tags: Option<&[&str]>) -> bool {
        match tags {
            None => true,
            Some(required) => required.iter().all(|t| instance.tags.contains(&t.to_string())),
        }
    }
}

impl ServiceRegistry for LocalRegistry {
    fn register(&self, mut instance: ServiceInstance) -> Result<(), Box<dyn std::error::Error>> {
        let mut services = self.services.write().unwrap();
        instance.last_heartbeat = Some(Instant::now());
        instance.health = HealthStatus::Healthy;
        services.insert(instance.service_id.clone(), instance);
        Ok(())
    }

    fn deregister(&self, service_id: &str) -> Result<(), Box<dyn std::error::Error>> {
        let mut services = self.services.write().unwrap();
        services.remove(service_id);
        Ok(())
    }

    fn discover(
        &self,
        service_name: &str,
        tags: Option<&[&str]>,
    ) -> Result<Vec<ServiceInstance>, Box<dyn std::error::Error>> {
        self.cleanup_expired();

        let services = self.services.read().unwrap();
        let results: Vec<ServiceInstance> = services
            .values()
            .filter(|inst| inst.service_name == service_name)
            .filter(|inst| inst.health == HealthStatus::Healthy)
            .filter(|inst| Self::has_all_tags(inst, tags))
            .cloned()
            .collect();

        Ok(results)
    }

    fn heartbeat(&self, service_id: &str) -> Result<(), Box<dyn std::error::Error>> {
        let mut services = self.services.write().unwrap();
        if let Some(instance) = services.get_mut(service_id) {
            instance.last_heartbeat = Some(Instant::now());
            instance.health = HealthStatus::Healthy;
            Ok(())
        } else {
            Err(format!("Service not found: {}", service_id).into())
        }
    }
}

lazy_static! {
    pub static ref REGISTRY: Arc<LocalRegistry> = Arc::new(LocalRegistry::new(Duration::from_secs(60)));
}
```

---

## Part 2: Distributed Tracing (Phase 8)

Distributed tracing provides observability across service boundaries, enabling developers to track requests as they flow through the system.

### Trace Exporters

| Exporter | Description | Protocol |
|----------|-------------|----------|
| `otlp` | OpenTelemetry Protocol | gRPC/HTTP |
| `jaeger` | Jaeger backend | Thrift/HTTP |
| `zipkin` | Zipkin backend | HTTP |
| `console` | Console output | stdout |

### Trace Propagation Formats

| Format | Description | Header |
|--------|-------------|--------|
| `w3c` | W3C Trace Context | `traceparent` |
| `b3` | Zipkin B3 format | `X-B3-TraceId` |
| `jaeger` | Jaeger format | `uber-trace-id` |

### Tracing Options

| Option | Values | Description |
|--------|--------|-------------|
| `tracing(Bool)` | `true`, `false` | Enable distributed tracing |
| `trace_exporter(Exporter)` | `otlp`, `jaeger`, `zipkin`, `console` | Export destination |
| `trace_sampling(Rate)` | Float 0.0-1.0 | Sampling rate |
| `trace_propagation(Format)` | `w3c`, `b3`, `jaeger` | Context propagation format |

### Defining a Traced Service

```prolog
service(order_api, [
    tracing(true),
    trace_exporter(otlp),
    trace_sampling(0.1),
    trace_propagation(w3c),
    transport(http(8080))
], [
    receive(OrderRequest),
    start_span(process_order),
    validate_order(OrderRequest),
    add_span_event(order_validated),
    create_order(Order),
    end_span,
    respond(Order)
]).
```

### Tracing Architecture

```
┌─────────────────────────────────────────────────────────────────┐
│                     Distributed Tracing                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  Request                                                         │
│     │                                                            │
│     ▼                                                            │
│  ┌───────────────────────────────────────────────────────────┐  │
│  │  Trace Context (W3C/B3/Jaeger)                             │  │
│  │  trace_id: abc123  span_id: def456  sampled: true         │  │
│  └───────────────────────────────────────────────────────────┘  │
│                          │                                       │
│     ┌────────────────────┼────────────────────┐                 │
│     │                    │                    │                  │
│     ▼                    ▼                    ▼                  │
│  ┌──────────┐      ┌──────────┐       ┌──────────┐             │
│  │ Service A│─────►│ Service B│──────►│ Service C│             │
│  │ Span 1   │      │ Span 2   │       │ Span 3   │             │
│  └────┬─────┘      └────┬─────┘       └────┬─────┘             │
│       │                 │                  │                    │
│       └─────────────────┼──────────────────┘                    │
│                         │                                       │
│                         ▼                                       │
│              ┌────────────────────┐                             │
│              │   Trace Exporter   │                             │
│              │  (OTLP/Jaeger/...)│                             │
│              └─────────┬──────────┘                             │
│                        │                                        │
│                        ▼                                        │
│              ┌────────────────────┐                             │
│              │   Trace Backend    │                             │
│              │  (Jaeger UI, etc) │                             │
│              └────────────────────┘                             │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### Python Tracing Implementation

```python
# Generated by UnifyWeaver - Distributed Tracing
import json
import random
import time
import threading
import urllib.request
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from enum import Enum
from typing import Dict, List, Optional, Any
from datetime import datetime
import uuid

class SpanKind(Enum):
    INTERNAL = "internal"
    SERVER = "server"
    CLIENT = "client"
    PRODUCER = "producer"
    CONSUMER = "consumer"

@dataclass
class SpanContext:
    """Context for distributed tracing propagation."""
    trace_id: str
    span_id: str
    trace_flags: int = 1  # sampled
    trace_state: str = ""

    @classmethod
    def new_root(cls) -> 'SpanContext':
        """Create a new root span context."""
        return cls(
            trace_id=uuid.uuid4().hex,
            span_id=uuid.uuid4().hex[:16],
            trace_flags=1
        )

    @classmethod
    def from_parent(cls, parent: 'SpanContext') -> 'SpanContext':
        """Create a child span context."""
        return cls(
            trace_id=parent.trace_id,
            span_id=uuid.uuid4().hex[:16],
            trace_flags=parent.trace_flags,
            trace_state=parent.trace_state
        )

    def to_w3c_header(self) -> str:
        """Format as W3C traceparent header."""
        return f"00-{self.trace_id}-{self.span_id}-{self.trace_flags:02x}"

    @classmethod
    def from_w3c_header(cls, header: str) -> Optional['SpanContext']:
        """Parse W3C traceparent header."""
        try:
            parts = header.split('-')
            if len(parts) != 4:
                return None
            return cls(
                trace_id=parts[1],
                span_id=parts[2],
                trace_flags=int(parts[3], 16)
            )
        except Exception:
            return None

    def to_b3_headers(self) -> Dict[str, str]:
        """Format as B3 headers."""
        return {
            'X-B3-TraceId': self.trace_id,
            'X-B3-SpanId': self.span_id,
            'X-B3-Sampled': '1' if self.trace_flags & 1 else '0'
        }

@dataclass
class SpanEvent:
    """An event that occurred during a span."""
    name: str
    timestamp: float
    attributes: Dict[str, Any] = field(default_factory=dict)

@dataclass
class Span:
    """A single span in a trace."""
    name: str
    context: SpanContext
    parent_span_id: Optional[str] = None
    kind: SpanKind = SpanKind.INTERNAL
    start_time: float = field(default_factory=time.time)
    end_time: Optional[float] = None
    attributes: Dict[str, Any] = field(default_factory=dict)
    events: List[SpanEvent] = field(default_factory=list)
    status_code: str = "OK"
    status_message: str = ""

    def set_attribute(self, key: str, value: Any) -> None:
        """Set a span attribute."""
        self.attributes[key] = value

    def add_event(self, name: str, attributes: Dict[str, Any] = None) -> None:
        """Add an event to the span."""
        self.events.append(SpanEvent(
            name=name,
            timestamp=time.time(),
            attributes=attributes or {}
        ))

    def set_status(self, code: str, message: str = "") -> None:
        """Set the span status."""
        self.status_code = code
        self.status_message = message

    def end(self) -> None:
        """End the span."""
        self.end_time = time.time()

    def to_dict(self) -> Dict[str, Any]:
        """Convert span to dictionary for export."""
        return {
            "name": self.name,
            "trace_id": self.context.trace_id,
            "span_id": self.context.span_id,
            "parent_span_id": self.parent_span_id,
            "kind": self.kind.value,
            "start_time": self.start_time,
            "end_time": self.end_time,
            "attributes": self.attributes,
            "events": [
                {"name": e.name, "timestamp": e.timestamp, "attributes": e.attributes}
                for e in self.events
            ],
            "status": {"code": self.status_code, "message": self.status_message}
        }

class SpanExporter(ABC):
    """Abstract base class for span exporters."""

    @abstractmethod
    def export(self, spans: List[Span]) -> bool:
        """Export a batch of spans."""
        pass

    @abstractmethod
    def shutdown(self) -> None:
        """Shutdown the exporter."""
        pass

class ConsoleExporter(SpanExporter):
    """Exports spans to console for debugging."""

    def export(self, spans: List[Span]) -> bool:
        for span in spans:
            print(f"[TRACE] {span.name} trace={span.context.trace_id[:8]}... "
                  f"span={span.context.span_id[:8]}... "
                  f"duration={(span.end_time - span.start_time)*1000:.2f}ms")
        return True

    def shutdown(self) -> None:
        pass

class OTLPExporter(SpanExporter):
    """Exports spans using OpenTelemetry Protocol."""

    def __init__(self, endpoint: str = "http://localhost:4318/v1/traces"):
        self._endpoint = endpoint

    def export(self, spans: List[Span]) -> bool:
        payload = {
            "resourceSpans": [{
                "resource": {"attributes": []},
                "scopeSpans": [{
                    "scope": {"name": "unifyweaver"},
                    "spans": [span.to_dict() for span in spans]
                }]
            }]
        }

        try:
            data = json.dumps(payload).encode('utf-8')
            request = urllib.request.Request(
                self._endpoint,
                data=data,
                headers={'Content-Type': 'application/json'},
                method='POST'
            )
            with urllib.request.urlopen(request, timeout=10) as response:
                return response.status == 200
        except Exception as e:
            print(f"Failed to export spans: {e}")
            return False

    def shutdown(self) -> None:
        pass

class JaegerExporter(SpanExporter):
    """Exports spans to Jaeger backend."""

    def __init__(self, endpoint: str = "http://localhost:14268/api/traces"):
        self._endpoint = endpoint

    def export(self, spans: List[Span]) -> bool:
        # Convert to Jaeger Thrift format (simplified)
        payload = {
            "process": {"serviceName": "unifyweaver"},
            "spans": [self._convert_span(span) for span in spans]
        }

        try:
            data = json.dumps(payload).encode('utf-8')
            request = urllib.request.Request(
                self._endpoint,
                data=data,
                headers={'Content-Type': 'application/json'},
                method='POST'
            )
            with urllib.request.urlopen(request, timeout=10) as response:
                return response.status in (200, 202)
        except Exception:
            return False

    def _convert_span(self, span: Span) -> Dict[str, Any]:
        return {
            "traceIdLow": int(span.context.trace_id[:16], 16),
            "traceIdHigh": int(span.context.trace_id[16:32], 16) if len(span.context.trace_id) > 16 else 0,
            "spanId": int(span.context.span_id, 16),
            "operationName": span.name,
            "startTime": int(span.start_time * 1000000),
            "duration": int((span.end_time - span.start_time) * 1000000) if span.end_time else 0
        }

    def shutdown(self) -> None:
        pass

class Tracer:
    """Main tracer class for creating and managing spans."""

    def __init__(self, exporter: SpanExporter, sampling_rate: float = 1.0):
        self._exporter = exporter
        self._sampling_rate = sampling_rate
        self._spans: List[Span] = []
        self._lock = threading.RLock()
        self._current_span: Optional[Span] = None
        self._span_stack: List[Span] = []

    def should_sample(self) -> bool:
        """Determine if a trace should be sampled."""
        return random.random() < self._sampling_rate

    def start_span(self, name: str, kind: SpanKind = SpanKind.INTERNAL,
                   parent_context: SpanContext = None) -> Span:
        """Start a new span."""
        if parent_context:
            context = SpanContext.from_parent(parent_context)
            parent_span_id = parent_context.span_id
        elif self._current_span:
            context = SpanContext.from_parent(self._current_span.context)
            parent_span_id = self._current_span.context.span_id
        else:
            context = SpanContext.new_root()
            parent_span_id = None

        span = Span(
            name=name,
            context=context,
            parent_span_id=parent_span_id,
            kind=kind
        )

        with self._lock:
            if self._current_span:
                self._span_stack.append(self._current_span)
            self._current_span = span

        return span

    def end_span(self, span: Span = None) -> None:
        """End a span and queue for export."""
        if span is None:
            span = self._current_span

        if span:
            span.end()
            with self._lock:
                self._spans.append(span)
                if self._span_stack:
                    self._current_span = self._span_stack.pop()
                else:
                    self._current_span = None

    def flush(self) -> None:
        """Export all pending spans."""
        with self._lock:
            if self._spans:
                self._exporter.export(self._spans)
                self._spans = []

    def shutdown(self) -> None:
        """Shutdown the tracer."""
        self.flush()
        self._exporter.shutdown()

# Configuration
SAMPLING_RATE = 0.1
EXPORTER = OTLPExporter()
TRACER = Tracer(EXPORTER, SAMPLING_RATE)
```

### Go Tracing Implementation

```go
// Generated by UnifyWeaver - Distributed Tracing
package main

import (
    "bytes"
    "context"
    "encoding/json"
    "fmt"
    "math/rand"
    "net/http"
    "strconv"
    "strings"
    "sync"
    "time"

    "github.com/google/uuid"
)

// SpanKind represents the type of span
type SpanKind int

const (
    SpanKindInternal SpanKind = iota
    SpanKindServer
    SpanKindClient
    SpanKindProducer
    SpanKindConsumer
)

// SpanContext carries trace context across boundaries
type SpanContext struct {
    TraceID    string
    SpanID     string
    TraceFlags byte
    TraceState string
}

// NewRootContext creates a new root span context
func NewRootContext() SpanContext {
    return SpanContext{
        TraceID:    uuid.New().String(),
        SpanID:     uuid.New().String()[:16],
        TraceFlags: 1, // sampled
    }
}

// NewChildContext creates a child span context
func NewChildContext(parent SpanContext) SpanContext {
    return SpanContext{
        TraceID:    parent.TraceID,
        SpanID:     uuid.New().String()[:16],
        TraceFlags: parent.TraceFlags,
        TraceState: parent.TraceState,
    }
}

// ToW3CHeader formats as W3C traceparent header
func (sc SpanContext) ToW3CHeader() string {
    return fmt.Sprintf("00-%s-%s-%02x", sc.TraceID, sc.SpanID, sc.TraceFlags)
}

// ParseW3CHeader parses W3C traceparent header
func ParseW3CHeader(header string) (SpanContext, error) {
    parts := strings.Split(header, "-")
    if len(parts) != 4 {
        return SpanContext{}, fmt.Errorf("invalid traceparent format")
    }

    flags, err := strconv.ParseInt(parts[3], 16, 8)
    if err != nil {
        return SpanContext{}, err
    }

    return SpanContext{
        TraceID:    parts[1],
        SpanID:     parts[2],
        TraceFlags: byte(flags),
    }, nil
}

// ToB3Headers formats as B3 headers
func (sc SpanContext) ToB3Headers() map[string]string {
    sampled := "0"
    if sc.TraceFlags&1 == 1 {
        sampled = "1"
    }
    return map[string]string{
        "X-B3-TraceId": sc.TraceID,
        "X-B3-SpanId":  sc.SpanID,
        "X-B3-Sampled": sampled,
    }
}

// SpanEvent represents an event during a span
type SpanEvent struct {
    Name       string
    Timestamp  time.Time
    Attributes map[string]interface{}
}

// Span represents a single span in a trace
type Span struct {
    Name         string
    Context      SpanContext
    ParentSpanID string
    Kind         SpanKind
    StartTime    time.Time
    EndTime      time.Time
    Attributes   map[string]interface{}
    Events       []SpanEvent
    StatusCode   string
    StatusMsg    string
    ended        bool
    mu           sync.Mutex
}

// SetAttribute sets a span attribute
func (s *Span) SetAttribute(key string, value interface{}) {
    s.mu.Lock()
    defer s.mu.Unlock()
    s.Attributes[key] = value
}

// AddEvent adds an event to the span
func (s *Span) AddEvent(name string, attrs map[string]interface{}) {
    s.mu.Lock()
    defer s.mu.Unlock()
    s.Events = append(s.Events, SpanEvent{
        Name:       name,
        Timestamp:  time.Now(),
        Attributes: attrs,
    })
}

// SetStatus sets the span status
func (s *Span) SetStatus(code, message string) {
    s.mu.Lock()
    defer s.mu.Unlock()
    s.StatusCode = code
    s.StatusMsg = message
}

// End ends the span
func (s *Span) End() {
    s.mu.Lock()
    defer s.mu.Unlock()
    if !s.ended {
        s.EndTime = time.Now()
        s.ended = true
    }
}

// SpanExporter interface for exporting spans
type SpanExporter interface {
    Export(spans []*Span) error
    Shutdown() error
}

// ConsoleExporter exports spans to console
type ConsoleExporter struct{}

func (e *ConsoleExporter) Export(spans []*Span) error {
    for _, span := range spans {
        duration := span.EndTime.Sub(span.StartTime)
        fmt.Printf("[TRACE] %s trace=%s... span=%s... duration=%.2fms\n",
            span.Name,
            span.Context.TraceID[:8],
            span.Context.SpanID[:8],
            float64(duration.Microseconds())/1000)
    }
    return nil
}

func (e *ConsoleExporter) Shutdown() error {
    return nil
}

// OTLPExporter exports spans via OTLP
type OTLPExporter struct {
    endpoint string
    client   *http.Client
}

func NewOTLPExporter(endpoint string) *OTLPExporter {
    return &OTLPExporter{
        endpoint: endpoint,
        client:   &http.Client{Timeout: 10 * time.Second},
    }
}

func (e *OTLPExporter) Export(spans []*Span) error {
    payload := map[string]interface{}{
        "resourceSpans": []map[string]interface{}{{
            "resource":   map[string]interface{}{"attributes": []interface{}{}},
            "scopeSpans": []map[string]interface{}{{
                "scope": map[string]string{"name": "unifyweaver"},
                "spans": e.convertSpans(spans),
            }},
        }},
    }

    data, err := json.Marshal(payload)
    if err != nil {
        return err
    }

    resp, err := e.client.Post(e.endpoint, "application/json", bytes.NewReader(data))
    if err != nil {
        return err
    }
    defer resp.Body.Close()

    return nil
}

func (e *OTLPExporter) convertSpans(spans []*Span) []map[string]interface{} {
    result := make([]map[string]interface{}, len(spans))
    for i, span := range spans {
        result[i] = map[string]interface{}{
            "name":          span.Name,
            "traceId":       span.Context.TraceID,
            "spanId":        span.Context.SpanID,
            "parentSpanId":  span.ParentSpanID,
            "startTimeUnix": span.StartTime.UnixNano(),
            "endTimeUnix":   span.EndTime.UnixNano(),
            "attributes":    span.Attributes,
        }
    }
    return result
}

func (e *OTLPExporter) Shutdown() error {
    return nil
}

// Tracer manages span creation and export
type Tracer struct {
    exporter     SpanExporter
    samplingRate float64
    spans        []*Span
    currentSpan  *Span
    spanStack    []*Span
    mu           sync.Mutex
}

// NewTracer creates a new tracer
func NewTracer(exporter SpanExporter, samplingRate float64) *Tracer {
    return &Tracer{
        exporter:     exporter,
        samplingRate: samplingRate,
        spans:        make([]*Span, 0),
        spanStack:    make([]*Span, 0),
    }
}

// ShouldSample determines if a trace should be sampled
func (t *Tracer) ShouldSample() bool {
    return rand.Float64() < t.samplingRate
}

// StartSpan starts a new span
func (t *Tracer) StartSpan(ctx context.Context, name string, kind SpanKind) (*Span, context.Context) {
    t.mu.Lock()
    defer t.mu.Unlock()

    var spanCtx SpanContext
    var parentSpanID string

    if t.currentSpan != nil {
        spanCtx = NewChildContext(t.currentSpan.Context)
        parentSpanID = t.currentSpan.Context.SpanID
    } else {
        spanCtx = NewRootContext()
    }

    span := &Span{
        Name:         name,
        Context:      spanCtx,
        ParentSpanID: parentSpanID,
        Kind:         kind,
        StartTime:    time.Now(),
        Attributes:   make(map[string]interface{}),
        Events:       make([]SpanEvent, 0),
        StatusCode:   "OK",
    }

    if t.currentSpan != nil {
        t.spanStack = append(t.spanStack, t.currentSpan)
    }
    t.currentSpan = span

    return span, context.WithValue(ctx, "span", span)
}

// EndSpan ends a span
func (t *Tracer) EndSpan(span *Span) {
    if span == nil {
        span = t.currentSpan
    }

    if span != nil {
        span.End()

        t.mu.Lock()
        t.spans = append(t.spans, span)
        if len(t.spanStack) > 0 {
            t.currentSpan = t.spanStack[len(t.spanStack)-1]
            t.spanStack = t.spanStack[:len(t.spanStack)-1]
        } else {
            t.currentSpan = nil
        }
        t.mu.Unlock()
    }
}

// Flush exports pending spans
func (t *Tracer) Flush() {
    t.mu.Lock()
    spans := t.spans
    t.spans = make([]*Span, 0)
    t.mu.Unlock()

    if len(spans) > 0 {
        t.exporter.Export(spans)
    }
}

// Shutdown shuts down the tracer
func (t *Tracer) Shutdown() {
    t.Flush()
    t.exporter.Shutdown()
}

// Configuration
var (
    SamplingRate = 0.1
    Exporter     = NewOTLPExporter("http://localhost:4318/v1/traces")
    GlobalTracer = NewTracer(Exporter, SamplingRate)
)
```

### Rust Tracing Implementation

```rust
// Generated by UnifyWeaver - Distributed Tracing
use lazy_static::lazy_static;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::sync::{Arc, Mutex, RwLock};
use std::time::{Duration, Instant, SystemTime, UNIX_EPOCH};
use uuid::Uuid;

#[derive(Clone, Copy, Debug, PartialEq, Serialize, Deserialize)]
pub enum SpanKind {
    Internal,
    Server,
    Client,
    Producer,
    Consumer,
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct SpanContext {
    pub trace_id: String,
    pub span_id: String,
    pub trace_flags: u8,
    pub trace_state: String,
}

impl SpanContext {
    pub fn new_root() -> Self {
        SpanContext {
            trace_id: Uuid::new_v4().to_string().replace("-", ""),
            span_id: Uuid::new_v4().to_string().replace("-", "")[..16].to_string(),
            trace_flags: 1, // sampled
            trace_state: String::new(),
        }
    }

    pub fn new_child(parent: &SpanContext) -> Self {
        SpanContext {
            trace_id: parent.trace_id.clone(),
            span_id: Uuid::new_v4().to_string().replace("-", "")[..16].to_string(),
            trace_flags: parent.trace_flags,
            trace_state: parent.trace_state.clone(),
        }
    }

    pub fn to_w3c_header(&self) -> String {
        format!("00-{}-{}-{:02x}", self.trace_id, self.span_id, self.trace_flags)
    }

    pub fn from_w3c_header(header: &str) -> Option<Self> {
        let parts: Vec<&str> = header.split('-').collect();
        if parts.len() != 4 {
            return None;
        }

        let trace_flags = u8::from_str_radix(parts[3], 16).ok()?;

        Some(SpanContext {
            trace_id: parts[1].to_string(),
            span_id: parts[2].to_string(),
            trace_flags,
            trace_state: String::new(),
        })
    }

    pub fn to_b3_headers(&self) -> HashMap<String, String> {
        let mut headers = HashMap::new();
        headers.insert("X-B3-TraceId".to_string(), self.trace_id.clone());
        headers.insert("X-B3-SpanId".to_string(), self.span_id.clone());
        headers.insert(
            "X-B3-Sampled".to_string(),
            if self.trace_flags & 1 == 1 { "1" } else { "0" }.to_string(),
        );
        headers
    }
}

#[derive(Clone, Debug, Serialize)]
pub struct SpanEvent {
    pub name: String,
    pub timestamp: u64,
    pub attributes: HashMap<String, serde_json::Value>,
}

#[derive(Clone, Debug, Serialize)]
pub struct Span {
    pub name: String,
    pub context: SpanContext,
    pub parent_span_id: Option<String>,
    pub kind: SpanKind,
    pub start_time: u64,
    pub end_time: Option<u64>,
    pub attributes: HashMap<String, serde_json::Value>,
    pub events: Vec<SpanEvent>,
    pub status_code: String,
    pub status_message: String,
}

impl Span {
    pub fn new(name: &str, context: SpanContext, parent_span_id: Option<String>, kind: SpanKind) -> Self {
        let start_time = SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .unwrap()
            .as_nanos() as u64;

        Span {
            name: name.to_string(),
            context,
            parent_span_id,
            kind,
            start_time,
            end_time: None,
            attributes: HashMap::new(),
            events: Vec::new(),
            status_code: "OK".to_string(),
            status_message: String::new(),
        }
    }

    pub fn set_attribute(&mut self, key: &str, value: serde_json::Value) {
        self.attributes.insert(key.to_string(), value);
    }

    pub fn add_event(&mut self, name: &str, attributes: HashMap<String, serde_json::Value>) {
        let timestamp = SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .unwrap()
            .as_nanos() as u64;

        self.events.push(SpanEvent {
            name: name.to_string(),
            timestamp,
            attributes,
        });
    }

    pub fn set_status(&mut self, code: &str, message: &str) {
        self.status_code = code.to_string();
        self.status_message = message.to_string();
    }

    pub fn end(&mut self) {
        if self.end_time.is_none() {
            self.end_time = Some(
                SystemTime::now()
                    .duration_since(UNIX_EPOCH)
                    .unwrap()
                    .as_nanos() as u64,
            );
        }
    }
}

pub trait SpanExporter: Send + Sync {
    fn export(&self, spans: &[Span]) -> Result<(), Box<dyn std::error::Error>>;
    fn shutdown(&self);
}

pub struct ConsoleExporter;

impl SpanExporter for ConsoleExporter {
    fn export(&self, spans: &[Span]) -> Result<(), Box<dyn std::error::Error>> {
        for span in spans {
            let duration = span.end_time.unwrap_or(span.start_time) - span.start_time;
            println!(
                "[TRACE] {} trace={}... span={}... duration={:.2}ms",
                span.name,
                &span.context.trace_id[..8],
                &span.context.span_id[..8],
                duration as f64 / 1_000_000.0
            );
        }
        Ok(())
    }

    fn shutdown(&self) {}
}

pub struct Tracer {
    exporter: Arc<dyn SpanExporter>,
    sampling_rate: f64,
    spans: Mutex<Vec<Span>>,
    current_span: RwLock<Option<Span>>,
    span_stack: Mutex<Vec<Span>>,
}

impl Tracer {
    pub fn new(exporter: Arc<dyn SpanExporter>, sampling_rate: f64) -> Self {
        Tracer {
            exporter,
            sampling_rate,
            spans: Mutex::new(Vec::new()),
            current_span: RwLock::new(None),
            span_stack: Mutex::new(Vec::new()),
        }
    }

    pub fn should_sample(&self) -> bool {
        rand::random::<f64>() < self.sampling_rate
    }

    pub fn start_span(&self, name: &str, kind: SpanKind) -> Span {
        let current = self.current_span.read().unwrap();
        let (context, parent_span_id) = if let Some(ref parent) = *current {
            (SpanContext::new_child(&parent.context), Some(parent.context.span_id.clone()))
        } else {
            (SpanContext::new_root(), None)
        };
        drop(current);

        let span = Span::new(name, context, parent_span_id, kind);

        // Push current to stack and set new current
        let mut stack = self.span_stack.lock().unwrap();
        if let Some(current_span) = self.current_span.write().unwrap().take() {
            stack.push(current_span);
        }
        *self.current_span.write().unwrap() = Some(span.clone());

        span
    }

    pub fn end_span(&self, mut span: Span) {
        span.end();

        // Add to export queue
        self.spans.lock().unwrap().push(span);

        // Pop from stack
        let mut stack = self.span_stack.lock().unwrap();
        *self.current_span.write().unwrap() = stack.pop();
    }

    pub fn flush(&self) {
        let spans: Vec<Span> = {
            let mut guard = self.spans.lock().unwrap();
            std::mem::take(&mut *guard)
        };

        if !spans.is_empty() {
            let _ = self.exporter.export(&spans);
        }
    }

    pub fn shutdown(&self) {
        self.flush();
        self.exporter.shutdown();
    }
}

lazy_static! {
    pub static ref TRACER: Tracer = Tracer::new(
        Arc::new(ConsoleExporter),
        0.1 // 10% sampling
    );
}
```

---

## Complete Example: Traced Discoverable Service

```prolog
% A complete service with discovery and tracing
service(order_service, [
    % Discovery configuration
    discovery_enabled(true),
    discovery_backend(consul),
    health_check(http('/health', 30000)),
    discovery_ttl(60),
    discovery_tags([production, v2]),

    % Tracing configuration
    tracing(true),
    trace_exporter(otlp),
    trace_sampling(0.1),
    trace_propagation(w3c),

    % Transport
    transport(http(8080))
], [
    % Health endpoint
    handle(get_health, [], respond(ok)),

    % Create order with tracing
    handle(create_order, [OrderData],
        start_span(create_order),
        validate_order(OrderData),
        add_span_event(validated),
        discover_service(inventory_service, [production], InventoryEndpoint),
        call_service(InventoryEndpoint, reserve_items, OrderData.items),
        add_span_event(items_reserved),
        persist_order(Order),
        end_span,
        respond(Order)
    )
]).
```

## Summary

This chapter covered:

**Service Discovery (Phase 7)**:
- Discovery backends: Consul, etcd, DNS, Kubernetes
- Health checking with HTTP and TCP probes
- ServiceRegistry abstraction with LocalRegistry and ConsulRegistry
- Heartbeat and TTL-based expiration
- Service tags for filtering

**Distributed Tracing (Phase 8)**:
- Trace context propagation (W3C, B3, Jaeger formats)
- Span management with parent-child relationships
- SpanExporter abstraction for multiple backends
- Sampling rate configuration
- Integration with OTLP, Jaeger, and Zipkin

Together with Chapters 11a, 12a, and 12b, this completes the client-server architecture documentation, covering all 8 phases from basic in-process services to production-grade distributed systems with observability.
