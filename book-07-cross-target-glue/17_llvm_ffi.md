<!--
SPDX-License-Identifier: MIT AND CC-BY-4.0
Copyright (c) 2025 John William Creighton (s243a)

This documentation is dual-licensed under MIT and CC-BY-4.0.
-->

# Chapter 17: LLVM Foreign Function Interface

Integrate LLVM-compiled Prolog predicates with Go and Rust via C ABI.

## Overview

UnifyWeaver's LLVM target can generate shared libraries (`.so`) that export C-compatible functions. These can be called from:
- **C/C++** directly
- **Go** via cgo
- **Rust** via FFI

## Why LLVM for Cross-Language Glue?

| Approach | Pros | Cons |
|----------|------|------|
| Subprocess pipes | Simple | Overhead, serialization |
| HTTP/gRPC | Networked | Latency |
| **LLVM shared lib** | **Zero-copy, native speed** | Build complexity |

## Workflow

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚            UnifyWeaver                    â”‚
â”‚  compile_shared_library_llvm/3            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â”‚
                  â–¼
           prolog_math.ll
                  â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â–¼             â–¼             â–¼
 prolog_math.h  lib.go       lib.rs
 (C header)    (cgo)        (FFI)
```

## Generating the Shared Library

```prolog
?- use_module('src/unifyweaver/targets/llvm_target').

% Define functions to export
?- compile_shared_library_llvm(
       [func(sum, 2, tail_recursion),
        func(factorial, 1, factorial),
        func(fib, 2, linear_recursion)],
       [library_name(prolog_math)],
       Code),
   write_llvm_program(Code, 'prolog_math.ll').

% Generate C header
?- generate_c_header(Functions, Header),
   atom_string(Header, S),
   open('prolog_math.h', write, F),
   write(F, S),
   close(F).
```

### Build Commands

```bash
# Fix Prolog escaping (double %%)
sed -i 's/%%/%/g' prolog_math.ll

# Compile to position-independent object
llc -filetype=obj -relocation-model=pic prolog_math.ll -o prolog_math.o

# Create shared library
clang -shared prolog_math.o -o libprolog_math.so

# Verify exports
nm -D libprolog_math.so | grep " T "
#   T factorial
#   T fib
#   T sum
```

## Go Integration (cgo)

### Generate Go Bindings

```prolog
?- generate_cgo_bindings(
       [func(sum, 2, tail_recursion), func(factorial, 1, factorial)],
       GoCode),
   write(GoCode).
```

### Output: `prologmath.go`

```go
// Generated by UnifyWeaver LLVM Target
package prologmath

/*
#cgo LDFLAGS: -L. -lprolog_math
#include "prolog_math.h"
*/
import "C"

// sum calls the LLVM-compiled sum function
func Sum(n int64) int64 {
    return int64(C.sum(C.int64_t(n)))
}

// factorial calls the LLVM-compiled factorial function
func Factorial(n int64) int64 {
    return int64(C.factorial(C.int64_t(n)))
}
```

### Usage

```go
package main

import (
    "fmt"
    "prologmath"
)

func main() {
    fmt.Println("sum(10) =", prologmath.Sum(10))       // 55
    fmt.Println("10! =", prologmath.Factorial(10))     // 3628800
}
```

### Build

```bash
CGO_ENABLED=1 go build
LD_LIBRARY_PATH=. ./program
```

## Rust Integration (FFI)

### Generate Rust Bindings

```prolog
?- generate_rust_ffi(
       [func(sum, 2, tail_recursion), func(factorial, 1, factorial)],
       RustCode),
   write(RustCode).
```

### Output: `lib.rs`

```rust
// Generated by UnifyWeaver LLVM Target - Rust FFI

mod ffi {
    extern "C" {
        fn sum(n: i64) -> i64;
        fn factorial(n: i64) -> i64;
    }
}

/// Calls the LLVM-compiled sum function
pub fn sum(n: i64) -> i64 {
    unsafe { ffi::sum(n) }
}

/// Calls the LLVM-compiled factorial function
pub fn factorial(n: i64) -> i64 {
    unsafe { ffi::factorial(n) }
}
```

### Cargo.toml

```toml
[package]
name = "prolog_math"
version = "0.1.0"
edition = "2021"

[lib]
crate-type = ["cdylib", "rlib"]

[build-dependencies]
cc = "1.0"
```

### Usage

```rust
use prolog_math::{sum, factorial};

fn main() {
    println!("sum(10) = {}", sum(10));         // 55
    println!("10! = {}", factorial(10));       // 3628800
}
```

### Build

```bash
cargo build
LD_LIBRARY_PATH=. cargo run
```

## Advantages Over Other Glue Methods

| Feature | LLVM FFI | Subprocess | HTTP |
|---------|----------|------------|------|
| Latency | **<1Î¼s** | ~1ms | ~10ms |
| Data copy | **None** | Serialize | Serialize |
| Type safety | **Native** | String | JSON |
| Concurrency | **Thread-safe** | Process | Network |

## Use Cases

1. **Performance-critical loops**: Call recursive Prolog from tight Go/Rust loops
2. **Embedded systems**: Link LLVM .o directly into firmware
3. **Microservices**: Expose Prolog as native library for polyglot services

---

**â†** [Previous: Cloud Enterprise](16_cloud_enterprise.md) | [ðŸ“– Book: Cross-Target Glue](./)
