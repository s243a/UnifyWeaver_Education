<!--
SPDX-License-Identifier: MIT AND CC-BY-4.0
Copyright (c) 2025 John William Creighton (s243a)
-->

# Chapter 2: Basic Compilation

In this chapter, we will compile simple Prolog predicates into single-file Rust programs.

## Compiling Facts

### Prolog Source (`facts.pl`)

```prolog
:- use_module('src/unifyweaver/targets/rust_target').

% Define facts
user(john, 25).
user(jane, 30).

% Compile to Rust
compile_facts :-
    compile_predicate_to_rust(user/2, [], Code),
    write_rust_program(Code, 'user.rs').
```

### Generated Rust Code

The compiler generates a Rust program using `HashSet` for facts.

```rust
use std::collections::HashSet;

fn main() {
    let mut facts = HashSet::new();
    facts.insert("john:25");
    facts.insert("jane:30");
    // ... iteration logic ...
}
```

### Running the Program

```bash
swipl -g compile_facts -t halt facts.pl
rustc user.rs
./user
# Output:
# john:25
# jane:30
```

### Using `compile_facts_to_rust/3` (Struct-Based Export)

For a more structured approach with type-safe access, use the `compile_facts_to_rust/3` API:

```prolog
?- ['facts.pl'].
?- rust_target:compile_facts_to_rust(user, 2, Code).
```

**Generated Rust Code:**

```rust
// Generated by UnifyWeaver Rust Target - Fact Export

#[derive(Debug, Clone, PartialEq, Eq)]
struct USER {
    arg1: String,
    arg2: String,
}

fn get_all_user() -> Vec<USER> {
    vec![
        USER { arg1: "john".to_string(), arg2: "25".to_string() },
        USER { arg1: "jane".to_string(), arg2: "30".to_string() },
    ]
}

fn stream_user() -> impl Iterator<Item = USER> {
    get_all_user().into_iter()
}

fn contains_user(target: &USER) -> bool {
    get_all_user().iter().any(|f| f == target)
}

fn main() {
    for fact in stream_user() {
        println!("{}", vec![fact.arg1.clone(), fact.arg2.clone()].join(":"));
    }
}
```

**Benefits of Struct-Based Export:**
- Type-safe access via struct fields
- Derives `Debug`, `Clone`, `PartialEq`, `Eq` for easy use
- `get_all`, `stream`, and `contains` helper functions
- Works with Rust's ownership and borrowing

## Compiling Rules

Rules are compiled into stream processors that read from stdin.

### Prolog Source (`rules.pl`)

```prolog
:- use_module('src/unifyweaver/targets/rust_target').

% Rule: Filter adults
adult(Name, Age) :- person(Name, Age), Age >= 18.

compile_rules :-
    compile_predicate_to_rust(adult/2, [field_delimiter(colon)], Code),
    write_rust_program(Code, 'adult.rs').
```

### Usage

```bash
swipl -g compile_rules -t halt rules.pl
rustc adult.rs
echo -e "alice:25\nbob:10" | ./adult
# Output:
# alice:25
```

## Tail Recursion Optimization

For accumulator patterns, use `compile_tail_recursion_rust/3`:

```prolog
assertz((sum_list([], Acc, Acc))).
assertz((sum_list([H|T], Acc, S) :- Acc1 is Acc + H, sum_list(T, Acc1, S))).

?- rust_target:compile_tail_recursion_rust(sum_list/3, [], Code).
```

**Generated Rust (O(1) stack):**
```rust
fn sum_list(items: &[i32], acc: i32) -> i32 {
    let mut result = acc;
    for &item in items {
        result += item;
    }
    result
}
```

## Linear Recursion with Memoization

For overlapping subproblems, use `compile_linear_recursion_rust/3`:

```prolog
assertz((triangular(0, 0))).
assertz((triangular(1, 1))).
assertz((triangular(N, F) :- N > 1, N1 is N - 1, triangular(N1, F1), F is F1 + N)).

?- rust_target:compile_linear_recursion_rust(triangular/2, [], Code).
```

**Generated Rust (HashMap memo):**
```rust
thread_local! {
    static TRIANGULAR_MEMO: RefCell<HashMap<i32, i32>> = RefCell::new(HashMap::new());
}

fn triangular(n: i32) -> i32 {
    if let Some(&result) = TRIANGULAR_MEMO.with(|m| m.borrow().get(&n).copied()) {
        return result;
    }
    // ... base cases and memoization
}
```

## Recursion Pattern Summary

| Pattern | API | Generated Rust |
|---------|-----|----------------|
| Tail Recursion | `compile_tail_recursion_rust/3` | for loop |
| Linear Recursion | `compile_linear_recursion_rust/3` | HashMap memo |

---

## Navigation

**‚Üê** [Previous: Chapter 1: Introduction to the Rust Target](01_introduction) | [üìñ Book 9: Rust Target](./) | [Next: Chapter 3: Project Generation ‚Üí](03_project_generation)
