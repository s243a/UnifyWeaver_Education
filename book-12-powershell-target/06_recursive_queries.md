<!--
SPDX-License-Identifier: MIT AND CC-BY-4.0
Copyright (c) 2025 John William Creighton (s243a)
-->

# Chapter 6: Recursive Queries

This chapter covers compiling recursive predicates like `ancestor/2` to PowerShell using BFS-based transitive closure with .NET collections.

## The Ancestor Problem

The classic transitive closure example demonstrates recursive query compilation:

```prolog
% family_tree.pl
parent(abraham, isaac).
parent(isaac, jacob).
parent(jacob, joseph).

ancestor(A, D) :- parent(A, D).
ancestor(A, D) :- parent(A, P), ancestor(P, D).
```

## Compiling to PowerShell

Use `compile_recursive/3` from the recursive compiler module:

```prolog
?- ['education/book-02-bash-target/examples/family_tree'].
?- use_module('src/unifyweaver/core/recursive_compiler').

?- compile_recursive(ancestor/2, [target(powershell)], Code),
   open('ancestor.ps1', write, S),
   write(S, Code),
   close(S).
```

## Generated PowerShell Code

The compiler generates BFS-based PowerShell code using .NET collections:

```powershell
# Generated by UnifyWeaver PowerShell Target
# Predicate: ancestor/2 (Transitive Closure)

class ANCESTORQuery {
    [hashtable] $BaseRelation = @{}

    [void] AddFact([string]$From, [string]$To) {
        if (-not $this.BaseRelation.ContainsKey($From)) {
            $this.BaseRelation[$From] = [System.Collections.ArrayList]::new()
        }
        $this.BaseRelation[$From].Add($To) | Out-Null
    }

    [string[]] FindAll([string]$Start) {
        $visited = @{}
        $queue = [System.Collections.Queue]::new()
        $results = [System.Collections.ArrayList]::new()

        $queue.Enqueue($Start)
        $visited[$Start] = $true

        while ($queue.Count -gt 0) {
            $current = $queue.Dequeue()

            if ($this.BaseRelation.ContainsKey($current)) {
                foreach ($next in $this.BaseRelation[$current]) {
                    if (-not $visited.ContainsKey($next)) {
                        $visited[$next] = $true
                        $queue.Enqueue($next)
                        $results.Add($next) | Out-Null
                    }
                }
            }
        }
        return $results.ToArray()
    }

    [bool] Check([string]$Start, [string]$Target) {
        return $this.FindAll($Start) -contains $Target
    }
}

# Main execution
$query = [ANCESTORQuery]::new()

# Load facts from pipeline or file
$input | ForEach-Object {
    $parts = $_ -split ':'
    if ($parts.Count -ge 2) {
        $query.AddFact($parts[0].Trim(), $parts[1].Trim())
    }
}

# Query based on arguments
if ($args.Count -ge 1) {
    $start = $args[0]
    if ($args.Count -ge 2) {
        # Check mode
        $target = $args[1]
        if ($query.Check($start, $target)) {
            Write-Output "$start`:$target"
        }
    } else {
        # FindAll mode
        foreach ($result in $query.FindAll($start)) {
            Write-Output "$start`:$result"
        }
    }
}
```

## Running the PowerShell Code

```powershell
# Run with facts from pipeline
@"
abraham:isaac
isaac:jacob
jacob:joseph
"@ -split "`n" | pwsh ancestor.ps1 abraham

# Output:
# abraham:isaac
# abraham:jacob
# abraham:joseph
```

Or using a file:

```powershell
Get-Content facts.txt | pwsh ancestor.ps1 abraham
```

## PowerShell-Specific Features

The generated code leverages PowerShell and .NET idioms:

| Feature | PowerShell/.NET Construct |
|---------|---------------------------|
| **Adjacency List** | `[hashtable]` with `ArrayList` values |
| **BFS Queue** | `[System.Collections.Queue]` |
| **Visited Set** | `[hashtable]` |
| **Stream Input** | Pipeline with `$input` |
| **String Split** | `-split ':'` operator |

## Class-Based Design

The generated PowerShell uses a class for encapsulation:

```powershell
class ANCESTORQuery {
    [hashtable] $BaseRelation = @{}
    
    [void] AddFact([string]$From, [string]$To) { ... }
    [string[]] FindAll([string]$Start) { ... }
    [bool] Check([string]$Start, [string]$Target) { ... }
}
```

This allows:
- Multiple query instances
- Reusable across scripts
- Integration with PowerShell modules

## Options

The `compile_recursive/3` predicate accepts these options for PowerShell:

| Option | Description |
|--------|-------------|
| `target(powershell)` | Generate PowerShell code |
| `mode(class)` | Use class-based output (default) |
| `delimiter(colon)` | Field delimiter for output |

## Integration with Cmdlets

The generated class integrates well with PowerShell cmdlets:

```powershell
# Load the script
. .\ancestor.ps1

# Use programmatically
$q = [ANCESTORQuery]::new()
$q.AddFact("a", "b")
$q.AddFact("b", "c")

# Query
$q.FindAll("a")   # Returns: b, c
$q.Check("a", "c") # Returns: True
```

## When to Use Recursive Compilation

Use `compile_recursive/3` when:
- You have transitive closure queries (ancestor, path finding)
- The recursion depth is unknown
- You need efficient BFS-based evaluation

For simple non-recursive rules, use `compile_predicate_to_powershell/3` instead.

---

## Navigation

**‚Üê** [Previous: Chapter 5: Windows Automation](05_windows_automation) | [üìñ Book 12: PowerShell Target](./)
