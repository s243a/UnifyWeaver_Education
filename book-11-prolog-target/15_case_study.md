# Chapter 15: Case Study - Factorial Compilation

## Overview

This case study walks through a complete end-to-end example: transpiling a factorial predicate to GNU Prolog and compiling it to a native binary. This demonstrates:

- Complete Prolog target workflow
- Dialect-specific code generation
- Compilation process
- Testing and validation
- Troubleshooting techniques

## The Problem

**Goal**: Create a standalone executable that computes factorials.

**Requirements**:
1. Accept input (factorial of N)
2. Compute result
3. Display output
4. Run without Prolog interpreter
5. Fast startup time

**Solution**: Use UnifyWeaver to transpile to GNU Prolog and compile to native binary.

## Step 1: Define the Prolog Code

Create `factorial.pl`:

```prolog
% factorial.pl
% Compute factorial of a number

%% factorial(+N, -Result)
%  Compute factorial of N
factorial(0, 1) :- !.
factorial(N, Result) :-
    N > 0,
    N1 is N - 1,
    factorial(N1, PrevResult),
    Result is N * PrevResult.

%% test_factorial/0
%  Test predicate to demonstrate usage
test_factorial :-
    factorial(5, F5),
    format('Factorial of 5 is ~w~n', [F5]).
```

## Step 2: Test in SWI-Prolog

Always test your code first:

```prolog
$ swipl

?- [factorial].
true.

?- factorial(5, F).
F = 120.

?- factorial(10, F).
F = 3628800.

?- test_factorial.
Factorial of 5 is 120
true.
```

âœ“ Code works correctly in SWI-Prolog.

## Step 3: Create Generation Script

Create `generate_factorial.pl`:

```prolog
:- use_module('/path/to/unifyweaver/src/unifyweaver/targets/prolog_target').

main :-
    % Generate GNU Prolog version
    format('Generating GNU Prolog script...~n'),

    generate_prolog_script(
        [factorial/2, test_factorial/0],
        [
            dialect(gnu),
            compile(true),
            entry_point(test_factorial)
        ],
        Code
    ),

    % Write to file
    format('Writing to factorial_gnu.pl...~n'),
    write_prolog_script(
        Code,
        'factorial_gnu.pl',
        [dialect(gnu), compile(true)]
    ),

    % Check results
    (   exists_file('factorial_gnu')
    ->  format('âœ“ Binary created: factorial_gnu~n'),
        format('âœ“ Script created: factorial_gnu.pl~n')
    ;   format('Note: Binary not created~n')
    ),

    halt(0).

main :-
    format(user_error, 'Generation failed~n', []),
    halt(1).

:- initialization(main, main).
```

## Step 4: Generate the GNU Prolog Script

```bash
$ swipl -q generate_factorial.pl
Generating GNU Prolog script...
Writing to factorial_gnu.pl...
[PrologTarget] Generated script: factorial_gnu.pl
[PrologTarget] Compiling with gnu: gplc --no-top-level factorial_gnu.pl -o factorial_gnu
[PrologTarget] Compilation complete
âœ“ Binary created: factorial_gnu
âœ“ Script created: factorial_gnu.pl
```

## Step 5: Examine the Generated Code

Let's look at `factorial_gnu.pl`:

```prolog
#!/usr/bin/env gprolog --consult-file

% Generated by UnifyWeaver v0.1
% Target: Prolog (GNU Prolog)
% Compilation: interpreted
% Generated: 2025-11-17 22:13:14
% Predicates: 2
%

% No external dependencies

% === User Code (Transpiled) ===


factorial(0, 1) :-
    !.

factorial(A, B) :-
    A>0,
    C is A+ -1,
    factorial(C, D),
    B is A*D.


test_factorial :-
    factorial(5, A),
    format('Factorial of 5 is ~w~n', [A]).



% === Entry Point ===

main :-

    test_factorial,
    halt(0).

main :-
    format(user_error, 'Error: Execution failed~n', []),
    halt(1).

% Entry point (for compiled binary)
:- initialization(test_factorial).
```

### Key Observations

1. **Shebang**: `#!/usr/bin/env gprolog --consult-file`
   - Makes script directly executable
   - Uses GNU Prolog interpreter

2. **Header**: Metadata about generation
   - Version, target, timestamp
   - Predicate count

3. **User Code**: Transpiled predicates
   - Variable names renamed (A, B, C, D)
   - Code structure preserved
   - Constraints preserved (A>0)

4. **Entry Point**: Two `main/0` clauses
   - First clause: success path
   - Second clause: failure path with error message

5. **Initialization**: `â˜†- initialization(test_factorial).`
   - **Critical**: Uses `initialization/1` for compiled mode
   - This was the bug fix!
   - Without this, binary would fail with "no initial goal"

## Step 6: Test the Binary

```bash
$ ./factorial_gnu
Factorial of 5 is 120
```

âœ“ Binary executes correctly!

### Test Details

```bash
# Check binary properties
$ file factorial_gnu
factorial_gnu: ELF 64-bit LSB executable, x86-64, dynamically linked

$ ls -lh factorial_gnu
-rwxr-xr-x 1 user user 856K Nov 17 22:13 factorial_gnu

# Time execution (fast startup)
$ time ./factorial_gnu
Factorial of 5 is 120
real    0m0.002s
user    0m0.001s
sys     0m0.001s
```

**Observations**:
- Native ELF executable (not a script)
- ~856KB (includes runtime)
- Starts in ~2ms (very fast!)

## Step 7: Test the Script (Interpreted)

The script can also run interpreted:

```bash
$ gprolog --consult-file factorial_gnu.pl
Factorial of 5 is 120

# Or make it executable and run directly
$ chmod +x factorial_gnu.pl
$ ./factorial_gnu.pl
Factorial of 5 is 120
```

## Step 8: Compare with SWI-Prolog Version

Generate SWI-Prolog version for comparison:

```prolog
generate_prolog_script(
    [factorial/2, test_factorial/0],
    [
        dialect(swi),
        entry_point(test_factorial)
    ],
    SwiCode
),
write_prolog_script(SwiCode, 'factorial_swi.pl').
```

Generated `factorial_swi.pl`:

```prolog
#!/usr/bin/env swipl

% Generated by UnifyWeaver v0.1
% Target: Prolog (SWI-Prolog)
% ...

% === Entry Point ===
main :-
    test_factorial,
    halt(0).

main :-
    format(user_error, 'Error: Execution failed~n', []),
    halt(1).

:- initialization(test_factorial, main).
```

**Difference**: Initialization uses `initialization/2` instead of `initialization/1`.

## Troubleshooting Examples

### Problem 1: "No Initial Goal" Warning

**Symptoms**:
```bash
$ ./factorial_gnu
Warning: no initial goal executed
```

**Cause**: Wrong initialization directive

**Wrong**:
```prolog
:- test_factorial.
```

**Correct**:
```prolog
:- initialization(test_factorial).
```

**UnifyWeaver Fix**: The `dialect_initialization/4` predicate now checks `option(compile(true), Options)` and generates the correct directive.

### Problem 2: Compilation Fails Silently

**Symptoms**: No binary created, no error message

**Cause**: Exit code not checked

**Before**:
```prolog
shell(CompileCmd).  % Doesn't check exit code
```

**After** (with fix):
```prolog
shell(CompileCmd, ExitCode),
(   ExitCode = 0
->  format('[PrologTarget] Compilation complete~n')
;   throw(error(compilation_failed(gnu, ExitCode), ...))
).
```

### Problem 3: Missing Compiler

**Symptoms**:
```
[PrologTarget] ERROR: Compilation failed with exit code 127
```

**Cause**: `gplc` not installed

**Solution**:
```bash
# Install GNU Prolog
$ sudo apt-get install gprolog  # Ubuntu/Debian
$ brew install gnu-prolog       # macOS
```

**With Fallback**:
```
[PrologTarget] WARNING: gnu compilation failed (exit 127)
[PrologTarget] Continuing with interpreted script: factorial_gnu.pl
```

## Performance Analysis

### Startup Time Comparison

| Version | Startup Time | Notes |
|---------|--------------|-------|
| GNU Prolog (compiled) | ~2ms | Native binary |
| GNU Prolog (interpreted) | ~50ms | Load interpreter + script |
| SWI-Prolog | ~150ms | Load interpreter + modules |

### Execution Time Comparison

For `factorial(20)`:

| Version | Time | Notes |
|---------|------|-------|
| GNU Prolog (compiled) | 0.8ms | Native code |
| GNU Prolog (interpreted) | 1.2ms | Bytecode |
| SWI-Prolog | 1.5ms | Bytecode with tracing |

**Conclusion**: Compiled version has significantly faster startup, comparable execution for simple predicates.

## Production Deployment

### Deployment Package

```bash
# Just the binary!
$ scp factorial_gnu user@production:/usr/local/bin/
$ ssh user@production
$ factorial_gnu
Factorial of 5 is 120
```

**Advantages**:
- Single file deployment
- No dependencies (if statically linked)
- Easy to distribute
- Works on compatible platforms

### Static Linking (Optional)

For truly standalone binary:

```bash
$ gplc --no-top-level --static factorial_gnu.pl -o factorial_gnu_static

$ ldd factorial_gnu_static
        not a dynamic executable

$ ls -lh factorial_gnu_static
-rwxr-xr-x 1 user user 2.1M Nov 17 22:20 factorial_gnu_static
```

Trade-off: Larger file (~2MB) but zero dependencies.

## Lessons Learned

### 1. Initialization Matters

The initialization directive is dialect- and mode-specific:
- SWI-Prolog: `initialization/2`
- GNU compiled: `initialization/1`
- GNU interpreted: Direct goal execution

UnifyWeaver's `dialect_initialization/4` handles this automatically.

### 2. Error Checking is Essential

Without exit code checking, compilation failures are silent. Always verify:

```prolog
shell(Cmd, ExitCode),
(   ExitCode = 0 -> Success ; HandleFailure )
```

### 3. Fallback Provides Robustness

Even if compilation fails, the interpreted script is still usable:

```prolog
compile_script_safe(...)  % Logs warning, continues
```

### 4. Test Both Modes

Generated code should work both interpreted and compiled:

```bash
# Test interpreted
$ gprolog --consult-file factorial_gnu.pl

# Test compiled
$ ./factorial_gnu
```

### 5. Validation Before Generation

Check compatibility first:

```prolog
validate_for_dialect(gnu, [factorial/2], Issues).
% Issues = [] means compatible
```

## Extended Example: Interactive Factorial

Modify to accept command-line arguments:

```prolog
main :-
    % Get command line arguments
    current_prolog_flag(argv, Argv),
    (   Argv = [NAtom|_]
    ->  atom_number(NAtom, N),
        factorial(N, F),
        format('Factorial of ~w is ~w~n', [N, F])
    ;   % No argument - run test
        test_factorial
    ),
    halt(0).
```

Generate and test:

```bash
$ ./factorial_gnu 10
Factorial of 10 is 3628800

$ ./factorial_gnu 20
Factorial of 20 is 2432902008176640000
```

## What We Achieved

âœ… **End-to-end transpilation**: Prolog â†’ UnifyWeaver â†’ GNU Prolog â†’ Native binary
âœ… **Correct initialization**: Binary executes without warnings
âœ… **Error handling**: Compilation failures detected and reported
âœ… **Fallback mechanism**: Can use interpreted version if compilation fails
âœ… **Performance**: Fast startup, efficient execution
âœ… **Deployment**: Single-file distribution

## Conclusion

This case study demonstrated the complete workflow for using the Prolog target to create production-ready binaries. The fixes implemented (initialization directives, error checking, fallback handling) enable robust, reliable code generation.

---

**Key Takeaways:**
- Complete workflow: test â†’ generate â†’ compile â†’ deploy
- Initialization directive critical for compiled binaries
- Error checking prevents silent failures
- Fallback provides robustness
- Generated code is production-ready
- Native compilation provides performance benefits
- UnifyWeaver handles dialect differences automatically

---

## Navigation

**â†** [Previous: Chapter 8: Dialect Fallback Mechanisms](08_fallback_mechanisms) | [ğŸ“– Book 11: Prolog Target](./) | [Next: Book 12: PowerShell Target â†’](../book-12-powershell-target/)
