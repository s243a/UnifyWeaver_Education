# Chapter 2: Architecture Overview

## The Transpilation Pipeline

The Prolog target follows a well-defined pipeline that transforms your source code into executable Prolog scripts. Understanding this architecture helps you:

- Debug issues when they arise
- Extend the system with new features
- Optimize generated code

## Core Components

The Prolog target consists of three main modules:

### 1. `prolog_target.pl` - Main Orchestrator

**Location**: `src/unifyweaver/targets/prolog_target.pl`

**Responsibilities**:
- Orchestrates the entire generation pipeline
- Analyzes dependencies in source code
- Generates complete Prolog scripts
- Handles compilation and script writing
- Provides error handling and fallback

**Key Predicates**:

```prolog
% Main entry point
generate_prolog_script(+UserPredicates, +Options, -ScriptCode)

% Dependency analysis
analyze_dependencies(+Predicates, -Dependencies)

% Output handling
write_prolog_script(+ScriptCode, +OutputPath, +Options)

% Compilation (with error checking)
compile_script(+Dialect, +ScriptPath)
compile_script_safe(+Dialect, +ScriptPath, +Options)
```

### 2. `prolog_dialects.pl` - Dialect Abstraction

**Location**: `src/unifyweaver/targets/prolog_dialects.pl`

**Responsibilities**:
- Provides dialect-specific code generation
- Abstracts differences between SWI-Prolog and GNU Prolog
- Validates code compatibility with target dialect
- Manages compilation commands

**Key Predicates**:

```prolog
% Dialect support
supported_dialect(+Dialect)
dialect_capabilities(+Dialect, -Capabilities)

% Code generation
dialect_shebang(+Dialect, -ShebangLine)
dialect_header(+Dialect, +Options, -HeaderCode)
dialect_imports(+Dialect, +Dependencies, -ImportCode)
dialect_initialization(+Dialect, +Goal, +Options, -InitCode)

% Compilation
dialect_compile_command(+Dialect, +ScriptPath, -Command)

% Validation
validate_for_dialect(+Dialect, +Predicates, -Issues)
```

### 3. `prolog_service_target.pl` - Service Integration

**Location**: `src/unifyweaver/targets/prolog_service_target.pl`

**Responsibilities**:
- Handles Prolog-as-a-service scenarios
- Manages persistent Prolog processes
- Coordinates with UnifyWeaver's service infrastructure

## The Generation Pipeline

Let's walk through what happens when you call `generate_prolog_script/3`:

```prolog
generate_prolog_script([factorial/2],
                      [dialect(gnu), compile(true), entry_point(test_factorial)],
                      ScriptCode)
```

### Step 0: Dialect Selection and Validation

```prolog
% Extract dialect from options (default: swi)
option(dialect(Dialect), Options, swi),

% Validate it's supported
supported_dialect(Dialect),

% Check code compatibility
validate_for_dialect(Dialect, UserPredicates, Issues)
```

**What happens**: Ensures the requested dialect exists and that your code is compatible with it.

### Step 1: Dependency Analysis

```prolog
analyze_dependencies(UserPredicates, Dependencies)
```

**What happens**: Scans your predicates to find:
- UnifyWeaver modules (partitioners, data sources, backends)
- Required strategies (fixed_size, hash_based, etc.)
- Plugin registrations needed

**Example output**:
```prolog
Dependencies = [
    module(unifyweaver(core/partitioner)),
    ensure_loaded(unifyweaver(core/partitioners/fixed_size)),
    plugin_registration(partitioner, fixed_size, fixed_size_partitioner)
]
```

### Step 2: Shebang Generation

```prolog
dialect_shebang(Dialect, ShebangCode)
```

**What happens**: Creates the executable shebang line.

**SWI-Prolog**:
```bash
#!/usr/bin/env swipl
```

**GNU Prolog**:
```bash
#!/usr/bin/env gprolog --consult-file
```

### Step 3: Header Generation

```prolog
dialect_header(Dialect, EnhancedOptions, HeaderCode)
```

**What happens**: Creates metadata comments about the script.

**Example output**:
```prolog
% Generated by UnifyWeaver v0.1
% Target: Prolog (GNU Prolog)
% Compilation: interpreted
% Generated: 2025-11-17 22:13:14
% Predicates: 2
```

### Step 4: Import Generation

```prolog
dialect_imports(Dialect, Dependencies, ImportsCode)
```

**What happens**: Converts dependency list into dialect-specific import statements.

**SWI-Prolog example**:
```prolog
:- use_module(unifyweaver(core/partitioner)).
:- ensure_loaded(unifyweaver(core/partitioners/fixed_size)).
```

**GNU Prolog**: May use different syntax or skip unsupported features.

### Step 5: User Code Transpilation

```prolog
generate_user_code(UserPredicates, Options, UserCode)
```

**What happens**: Extracts and formats your actual predicate definitions.

**Input**: `[factorial/2]`

**Output**:
```prolog
factorial(0, 1) :-
    !.

factorial(A, B) :-
    A>0,
    C is A+ -1,
    factorial(C, D),
    B is A*D.
```

### Step 6: Entry Point Generation

```prolog
generate_main_predicate(Options, MainCode)
```

**What happens**: Creates the `main/0` predicate that serves as the script's entry point.

**Output**:
```prolog
main :-
    test_factorial,
    halt(0).

main :-
    format(user_error, 'Error: Execution failed~n', []),
    halt(1).
```

### Step 7: Initialization Code

```prolog
dialect_initialization(Dialect, EntryGoal, Options, InitCode)
```

**What happens**: Generates dialect-specific initialization directives.

**GNU Prolog (compiled)**:
```prolog
% Entry point (for compiled binary)
:- initialization(test_factorial).
```

**GNU Prolog (interpreted)**:
```prolog
% Entry point (called on load)
:- test_factorial.
```

**SWI-Prolog**:
```prolog
:- initialization(test_factorial, main).
```

### Step 8: Assembly

```prolog
atomic_list_concat([
    ShebangCode,
    HeaderCode,
    ImportsCode,
    UserCode,
    '\n% === Entry Point ===',
    MainCode,
    InitCode
], '\n\n', ScriptCode)
```

**What happens**: Combines all pieces into the final script with proper spacing.

## Writing and Compilation

After generation, the script goes through output processing:

```prolog
write_prolog_script(ScriptCode, OutputPath, Options)
```

This predicate:

1. **Writes the file**:
   ```prolog
   open(OutputPath, write, Stream, [encoding(utf8)]),
   write(Stream, ScriptCode),
   close(Stream)
   ```

2. **Makes it executable**:
   ```prolog
   shell('chmod +x OutputPath')
   ```

3. **Compiles if requested**:
   ```prolog
   (   option(compile(true), Options)
   ->  compile_script_safe(Dialect, OutputPath, Options)
   ;   true
   )
   ```

## Error Handling and Fallback

The compilation step uses a safe wrapper:

```prolog
compile_script_safe(Dialect, ScriptPath, Options) :-
    catch(
        compile_script(Dialect, ScriptPath),
        error(compilation_failed(FailedDialect, ExitCode), Context),
        handle_compilation_failure(...)
    )
```

**Behavior**:
- Attempts compilation
- Catches failures (non-zero exit codes)
- Logs warnings
- Continues with interpreted script (unless `fail_on_compile_error(true)`)

## Module Structure

```
src/unifyweaver/targets/
â”‚
â”œâ”€â”€ prolog_target.pl           # Main orchestrator
â”‚   â”œâ”€â”€ generate_prolog_script/3
â”‚   â”œâ”€â”€ analyze_dependencies/2
â”‚   â”œâ”€â”€ write_prolog_script/3
â”‚   â””â”€â”€ compile_script_safe/3
â”‚
â”œâ”€â”€ prolog_dialects.pl         # Dialect abstraction
â”‚   â”œâ”€â”€ supported_dialect/1
â”‚   â”œâ”€â”€ dialect_*/* (code generation)
â”‚   â””â”€â”€ validate_for_dialect/3
â”‚
â””â”€â”€ prolog_service_target.pl   # Service integration
    â””â”€â”€ (service-specific logic)
```

## Data Flow Diagram

```
User Predicates â”€â”€â”
                  â”‚
Options â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â–º generate_prolog_script/3
                  â”‚            â”‚
                  â”‚            â”œâ”€â–º analyze_dependencies/2
                  â”‚            â”‚        â””â”€â–º Dependencies
                  â”‚            â”‚
                  â”‚            â”œâ”€â–º dialect_shebang/2
                  â”‚            â”œâ”€â–º dialect_header/3
                  â”‚            â”œâ”€â–º dialect_imports/3
                  â”‚            â”œâ”€â–º generate_user_code/3
                  â”‚            â”œâ”€â–º generate_main_predicate/2
                  â”‚            â””â”€â–º dialect_initialization/4
                  â”‚                     â”‚
                  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                        â–¼
                                  ScriptCode (atom)
                                        â”‚
                                        â–¼
                          write_prolog_script/3
                                        â”‚
                                        â”œâ”€â–º Write file
                                        â”œâ”€â–º chmod +x
                                        â””â”€â–º compile_script_safe/3
                                                 â”‚
                                                 â””â”€â–º gplc (if compile=true)
```

## Key Design Principles

### 1. **Separation of Concerns**
- Dialect logic isolated in `prolog_dialects.pl`
- Compilation logic separate from generation
- Error handling decoupled from core logic

### 2. **Extensibility**
- Adding new dialects requires only changes to `prolog_dialects.pl`
- New dependency types handled in `analyze_dependencies/2`
- Fallback strategies can be extended

### 3. **Robustness**
- Safe wrappers for potentially failing operations
- Validation before generation
- Graceful degradation on errors

### 4. **Testability**
- Each step is a separate predicate
- Clear inputs and outputs
- Minimal side effects (except I/O)

## What's Next?

In Chapter 3, we'll explore Prolog dialects in detail, understanding the capabilities and constraints of SWI-Prolog and GNU Prolog, and when to use each.

---

**Key Takeaways:**
- The Prolog target uses a multi-step pipeline
- Three main modules handle different responsibilities
- Code generation is separated from dialect-specific logic
- Safe wrappers provide error handling and fallback
- The architecture is designed for extensibility and robustness

---

## Navigation

**â†** [Previous: Chapter 1: Introduction to the Prolog Target](01_introduction) | [ğŸ“– Book 11: Prolog Target](./) | [Next: Chapter 3: Understanding Prolog Dialects â†’](03_dialects)
