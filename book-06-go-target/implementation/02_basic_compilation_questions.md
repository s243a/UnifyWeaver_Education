<!--
SPDX-License-Identifier: MIT AND CC-BY-4.0
Copyright (c) 2025 John William Creighton (s243a)
-->

# Chapter 2: Basic Compilation - Questions

Q&A companion for [02_basic_compilation_impl.md](./02_basic_compilation_impl.md).

---

## Question Index

1. [What does compile_predicate_to_go/3 do?](#b06c02-q-compile-predicate)
2. [What options are available for Go compilation?](#b06c02-q-options)
3. [How are Prolog facts compiled to Go?](#b06c02-q-facts-compilation)
4. [How are Prolog rules compiled to Go?](#b06c02-q-rules-compilation)
5. [What is compile_facts_to_go/3?](#b06c02-q-compile-facts)
6. [What helper functions are generated by compile_facts_to_go?](#b06c02-q-helper-functions)
7. [When should I use map-based vs struct-based export?](#b06c02-q-map-vs-struct)
8. [How do I change the field delimiter?](#b06c02-q-delimiter)
9. [What is the end-to-end compilation workflow?](#b06c02-q-workflow)

---

## Questions and Answers

### <a id="b06c02-q-compile-predicate"></a>Q1: What does compile_predicate_to_go/3 do?

**Answer**: `compile_predicate_to_go/3` compiles a Prolog predicate to Go source code. It takes a predicate/arity pair, a list of options, and returns the generated Go code as a string.

```prolog
compile_predicate_to_go(+Predicate/Arity, +Options, -Code)
```

The function:
1. Collects all clauses for the predicate
2. Classifies whether it's facts-only or has rules
3. Generates appropriate Go code (map-based for facts, stream processor for rules)

**See**: [compile_predicate_to_go/3](./02_basic_compilation_impl.md#compile_predicate_to_go3)

---

### <a id="b06c02-q-options"></a>Q2: What options are available for Go compilation?

**Answer**: Two main options control Go code generation:

| Option | Values | Default | Description |
|--------|--------|---------|-------------|
| `field_delimiter(D)` | `colon`, `tab`, `comma`, `pipe` | `colon` | Field separator |
| `unique(B)` | `true`, `false` | `true` | Enable deduplication |

Example:
```prolog
compile_predicate_to_go(user/2, [field_delimiter(tab), unique(false)], Code).
```

**See**: [Options](./02_basic_compilation_impl.md#options)

---

### <a id="b06c02-q-facts-compilation"></a>Q3: How are Prolog facts compiled to Go?

**Answer**: Prolog facts are compiled to a Go `map[string]bool` for O(1) lookup:

```prolog
% Prolog facts
user(john, 25).
user(jane, 30).
```

Becomes:

```go
facts := map[string]bool{
    "john:25": true,
    "jane:30": true,
}
```

The map keys are the fact arguments joined by the delimiter.

**See**: [Example: Facts Compilation](./02_basic_compilation_impl.md#example-facts-compilation)

---

### <a id="b06c02-q-rules-compilation"></a>Q4: How are Prolog rules compiled to Go?

**Answer**: Prolog rules are compiled to stdin/stdout stream processors:

```prolog
swap(Y, X) :- input(X, Y).
```

Becomes:

```go
scanner := bufio.NewScanner(os.Stdin)
for scanner.Scan() {
    parts := strings.Split(scanner.Text(), ":")
    if len(parts) >= 2 {
        fmt.Println(parts[1] + ":" + parts[0])
    }
}
```

The generated binary reads lines from stdin, transforms them according to the rule, and writes to stdout.

**See**: [Example: Rules Compilation](./02_basic_compilation_impl.md#example-rules-compilation)

---

### <a id="b06c02-q-compile-facts"></a>Q5: What is compile_facts_to_go/3?

**Answer**: `compile_facts_to_go/3` generates struct-based Go code for facts with helper functions:

```prolog
compile_facts_to_go(+Predicate, +Arity, -Code)
```

Unlike `compile_predicate_to_go/3`, it creates:
- A typed Go struct with `ArgN` fields
- Helper functions: `GetAll`, `Stream`, `Contains`

This provides better type safety and IDE support.

**See**: [compile_facts_to_go/3](./02_basic_compilation_impl.md#compile_facts_to_go3)

---

### <a id="b06c02-q-helper-functions"></a>Q6: What helper functions are generated by compile_facts_to_go?

**Answer**: Three helper functions are generated:

1. **GetAllFOO()** - Returns all facts as a `[]FOO` slice
2. **StreamFOO(fn func(FOO))** - Iterator with callback
3. **ContainsFOO(target FOO)** - Membership test

Example usage:
```go
// Get all facts
users := GetAllUSER()

// Iterate with callback
StreamUSER(func(u USER) {
    fmt.Println(u.Arg1)
})

// Check membership
exists := ContainsUSER(USER{Arg1: "john", Arg2: "25"})
```

**See**: [Generated Structure](./02_basic_compilation_impl.md#generated-structure)

---

### <a id="b06c02-q-map-vs-struct"></a>Q7: When should I use map-based vs struct-based export?

**Answer**: Choose based on your use case:

**Map-Based (`compile_predicate_to_go`)**:
- Fast O(1) membership testing
- Large datasets
- Simple key-value relationships

**Struct-Based (`compile_facts_to_go`)**:
- Processing/transforming data
- Integration with typed Go code
- When field names matter
- Full IDE autocompletion support

**See**: [Map-Based vs Struct-Based Export](./02_basic_compilation_impl.md#map-based-vs-struct-based-export)

---

### <a id="b06c02-q-delimiter"></a>Q8: How do I change the field delimiter?

**Answer**: Use the `field_delimiter` option:

```prolog
compile_predicate_to_go(user/2, [field_delimiter(tab)], Code).
```

Available delimiters:
- `colon` → `:` (default)
- `tab` → `\t`
- `comma` → `,`
- `pipe` → `|`

**See**: [Delimiter Options](./02_basic_compilation_impl.md#delimiter-options)

---

### <a id="b06c02-q-workflow"></a>Q9: What is the end-to-end compilation workflow?

**Answer**: The workflow has four steps:

```bash
# 1. Write Prolog source with compile goal
# 2. Run SWI-Prolog to generate Go
swipl -g compile_facts -t halt facts.pl

# 3. Build Go binary
go build -o user user.go

# 4. Execute
./user
```

The Prolog compiler generates Go source, which is then compiled by the Go toolchain.

**See**: [Compilation Workflow](./02_basic_compilation_impl.md#compilation-workflow)

---

## Summary

This chapter covers the fundamentals of compiling Prolog to Go:
- `compile_predicate_to_go/3` for map-based compilation
- `compile_facts_to_go/3` for struct-based compilation
- Options for delimiters and deduplication
- Stream processing for rules
