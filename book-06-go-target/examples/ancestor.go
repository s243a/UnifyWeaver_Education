// Generated by UnifyWeaver Go Generator Mode
// Date: 2025-12-09 12:58:57
// Predicate: ancestor

package main

import (
    "encoding/json"
    "fmt"
    "strconv"
)

// Fact represents a relation tuple
type Fact struct {
    Relation string                 `json:"relation"`
    Args     map[string]interface{} `json:"args"`
}

// Key returns a canonical string for set membership
func (f Fact) Key() string {
    b, _ := json.Marshal(f)
    return string(b)
}

// toFloat64 converts interface{} to float64 for aggregation
func toFloat64(v interface{}) (float64, bool) {
    switch val := v.(type) {
    case float64:
        return val, true
    case int:
        return float64(val), true
    case int64:
        return float64(val), true
    case string:
        f, err := strconv.ParseFloat(val, 64)
        return f, err == nil
    default:
        return 0, false
    }
}

// Index provides O(1) lookup by relation and argument value
type Index struct {
    // byArg[relation][argN][value] -> []*Fact
    byArg map[string]map[string]map[interface{}][]*Fact
}

// NewIndex creates an empty index
func NewIndex() *Index {
    return &Index{byArg: make(map[string]map[string]map[interface{}][]*Fact)}
}

// Add indexes a fact by all its arguments
func (idx *Index) Add(fact *Fact) {
    rel := fact.Relation
    if _, ok := idx.byArg[rel]; !ok {
        idx.byArg[rel] = make(map[string]map[interface{}][]*Fact)
    }
    for argName, argVal := range fact.Args {
        if _, ok := idx.byArg[rel][argName]; !ok {
            idx.byArg[rel][argName] = make(map[interface{}][]*Fact)
        }
        idx.byArg[rel][argName][argVal] = append(idx.byArg[rel][argName][argVal], fact)
    }
}

// Lookup returns facts matching relation, argument name, and value
func (idx *Index) Lookup(relation, argName string, value interface{}) []*Fact {
    if relIdx, ok := idx.byArg[relation]; ok {
        if argIdx, ok := relIdx[argName]; ok {
            return argIdx[value]
        }
    }
    return nil
}

// BuildIndex creates an index from all facts in the total map
func BuildIndex(total map[string]Fact) *Index {
    idx := NewIndex()
    for _, fact := range total {
        f := fact // Create copy for stable pointer
        idx.Add(&f)
    }
    return idx
}


// GetInitialFacts returns base facts for fixpoint computation
func GetInitialFacts() []Fact {
    return []Fact{
        {Relation: "parent", Args: map[string]interface{}{"arg0": "abraham", "arg1": "ishmael"}},
		{Relation: "parent", Args: map[string]interface{}{"arg0": "abraham", "arg1": "isaac"}},
		{Relation: "parent", Args: map[string]interface{}{"arg0": "sarah", "arg1": "isaac"}},
		{Relation: "parent", Args: map[string]interface{}{"arg0": "isaac", "arg1": "esau"}},
		{Relation: "parent", Args: map[string]interface{}{"arg0": "isaac", "arg1": "jacob"}},
		{Relation: "parent", Args: map[string]interface{}{"arg0": "rebekah", "arg1": "esau"}},
		{Relation: "parent", Args: map[string]interface{}{"arg0": "rebekah", "arg1": "jacob"}},
		{Relation: "parent", Args: map[string]interface{}{"arg0": "jacob", "arg1": "reuben"}},
		{Relation: "parent", Args: map[string]interface{}{"arg0": "jacob", "arg1": "simeon"}},
		{Relation: "parent", Args: map[string]interface{}{"arg0": "jacob", "arg1": "levi"}},
		{Relation: "parent", Args: map[string]interface{}{"arg0": "jacob", "arg1": "judah"}},
    }
}

func ApplyRule_1(fact Fact, total map[string]Fact, idx *Index) []Fact {
    var results []Fact
    // Case: Fact matches parent(_8390,_8392)
    func() {
        if fact.Relation != "parent" {
            return
        }

        results = append(results, Fact{Relation: "ancestor", Args: map[string]interface{}{"arg0": fact.Args["arg0"], "arg1": fact.Args["arg1"]}})
    }()

    // Case: Fact matches parent(_8390,_8392)
    func() {
        if fact.Relation != "parent" {
            return
        }

        results = append(results, Fact{Relation: "ancestor", Args: map[string]interface{}{"arg0": fact.Args["arg0"], "arg1": fact.Args["arg1"]}})
    }()
    return results
}

func ApplyRule_2(fact Fact, total map[string]Fact, idx *Index) []Fact {
    var results []Fact
    // Case: Fact matches parent(_8354,_8368)
    func() {
        if fact.Relation != "parent" {
            return
        }
    
    // Join with ancestor (indexed on arg0)
    for _, j1Ptr := range idx.Lookup("ancestor", "arg0", fact.Args["arg1"]) {
        j1 := *j1Ptr
        if true {

            results = append(results, Fact{Relation: "ancestor", Args: map[string]interface{}{"arg0": fact.Args["arg0"], "arg1": j1.Args["arg1"]}})
        }
    }

    }()

    // Case: Fact matches parent(_8354,_8368)
    func() {
        if fact.Relation != "parent" {
            return
        }
    
    // Join with ancestor (indexed on arg0)
    for _, j1Ptr := range idx.Lookup("ancestor", "arg0", fact.Args["arg1"]) {
        j1 := *j1Ptr
        if true {

            results = append(results, Fact{Relation: "ancestor", Args: map[string]interface{}{"arg0": fact.Args["arg0"], "arg1": j1.Args["arg1"]}})
        }
    }

    }()

    // Case: Fact matches ancestor(_8368,_8356)
    func() {
        if fact.Relation != "ancestor" {
            return
        }
    
    // Join with parent (indexed on arg1)
    for _, j1Ptr := range idx.Lookup("parent", "arg1", fact.Args["arg0"]) {
        j1 := *j1Ptr
        if true {

            results = append(results, Fact{Relation: "ancestor", Args: map[string]interface{}{"arg0": j1.Args["arg0"], "arg1": fact.Args["arg1"]}})
        }
    }

    }()

    // Case: Fact matches ancestor(_8368,_8356)
    func() {
        if fact.Relation != "ancestor" {
            return
        }
    
    // Join with parent (indexed on arg1)
    for _, j1Ptr := range idx.Lookup("parent", "arg1", fact.Args["arg0"]) {
        j1 := *j1Ptr
        if true {

            results = append(results, Fact{Relation: "ancestor", Args: map[string]interface{}{"arg0": j1.Args["arg0"], "arg1": fact.Args["arg1"]}})
        }
    }

    }()
    return results
}
// Solve runs fixpoint iteration until no new facts are derived
func Solve() map[string]Fact {
    total := make(map[string]Fact)
    
    // Initialize with base facts
    for _, fact := range GetInitialFacts() {
        total[fact.Key()] = fact
    }

    // Build initial index
    idx := BuildIndex(total)
    
    // Fixpoint iteration
    changed := true
    for changed {
        changed = false
        var newFacts []Fact
        
        for _, fact := range total {
			newFacts = append(newFacts, ApplyRule_1(fact, total, idx)...)
			newFacts = append(newFacts, ApplyRule_2(fact, total, idx)...)
        }
        
        // Add new facts to total and index
        for _, nf := range newFacts {
            key := nf.Key()
            if _, exists := total[key]; !exists {
                total[key] = nf
                idx.Add(&nf)
                changed = true
            }
        }
    }

    return total
}

func main() {
    result := Solve()
    for _, fact := range result {
        b, _ := json.Marshal(fact)
        fmt.Println(string(b))
    }
}

