# Chapter 3: The UnifyWeaver Architecture

Now that we have a grasp of basic Prolog, we can explore how UnifyWeaver translates these concepts into executable Bash scripts. This chapter provides a high-level overview of the compiler's architecture and its key components.

## The Core Concept Revisited

UnifyWeaver treats Prolog as a **declarative specification language** and Bash as an **efficient execution target**. The primary goal is not to replicate all of Prolog's features in Bash, but to compile a specific, useful subset of Prolog—data relationships and queries—into optimized scripts that work well in a Unix-style pipeline.

## The Compilation Pipeline

The transformation from a Prolog predicate to a Bash script follows a clear pipeline:

```
┌──────────────────┐
│ Prolog Predicate │
└────────┬─────────┘
         │
         ▼
┌──────────────────┐
│ Pattern Analysis │
└────────┬─────────┘
         │
    ┌────┴────┐
    │         │
    ▼         ▼
┌─────────┐ ┌───────────┐
│Non-Rec  │ │ Recursive │
│(Stream) │ │ (BFS/Memo)│
└────┬────┘ └─────┬─────┘
     │             │
     ▼             ▼
┌──────────────────┐
│ Template         │
│ Rendering        │
└──────────┬─────────┘
           │
           ▼
    ┌─────────────┐
    │ Bash Script │
    └─────────────┘
```

1.  **Prolog Predicate:** The process starts with the Prolog predicate you want to compile (e.g., `ancestor/2`).

2.  **Pattern Analysis:** The compiler first inspects the structure of the predicate's rules to classify it. The most important distinction it makes is: Is this predicate recursive?

3.  **Strategy Selection:**
    *   If the predicate is **not recursive**, it is handed off to the `stream_compiler`.
    *   If the predicate is **recursive**, it is passed to the `recursive_compiler` which performs a deeper analysis to identify the specific *type* of recursion (e.g., transitive closure).

4.  **Template Rendering:** Based on the analysis, the compiler selects an appropriate Bash code template. It then uses the `template_system` to inject the specific details of the Prolog predicate (like names and variable positions) into the template.

5.  **Bash Script:** The final output is a complete, executable Bash script or function.

## The Core Modules

The UnifyWeaver compiler is built on three core Prolog modules.

### 1. `template_system.pl`
This module is a simple but powerful templating engine. It works much like the popular Mustache templating system. It defines a set of Bash code snippets with placeholders (e.g., `{{predicate_name}}`) and provides a predicate to fill in these placeholders with actual values.

This design is crucial because it **separates the logic of compilation from the specifics of the Bash implementation**. If we wanted to optimize a Bash function or change how it works, we would only need to modify the template, not the compiler logic itself.

### 2. `stream_compiler.pl`
This module handles **non-recursive predicates**. It is designed to convert Prolog rules into streaming Unix pipelines. For example, a rule like `grandparent(X, Z) :- parent(X, Y), parent(Y, Z).` is conceptually turned into a pipeline where the output of the first `parent` call is streamed as input to the second.

It handles:
*   **Facts:** Converts them into efficient data structures in Bash (more on this below).
*   **Single Rules:** Translates them into a series of piped commands.
*   **Multiple Rules:** Combines the results of different rules, often using `sort -u` to ensure uniqueness.

### 3. `recursive_compiler.pl`
This is the most sophisticated part of UnifyWeaver. It analyzes and optimizes **recursive predicates**. Its most important job is to identify the **transitive closure** pattern, which we saw in the `transitive_dependency/2` example from the previous chapter.

Instead of implementing recursion directly in Bash (which can be clumsy and lead to stack depth issues), the `recursive_compiler` transforms this pattern into a highly optimized **Breadth-First Search (BFS)** algorithm.

This BFS implementation uses a work queue and an associative array (to keep track of visited nodes) to traverse the relationship graph. This approach is:
*   **Memory Efficient:** It processes the graph level by level.
*   **Cycle-Proof:** It correctly handles cycles in the data (e.g., `A -> B -> C -> A`) without getting stuck in an infinite loop.
*   **Fast:** It avoids the overhead of recursive function calls in Bash.

## Structure of the Generated Bash Code

The Bash code generated by UnifyWeaver follows a consistent structure.

### Facts as Associative Arrays

Prolog facts are typically compiled into a `declare -A` statement, which creates an **associative array** (also known as a hash map or dictionary). This allows for O(1), or constant time, lookups.

For a predicate like `parent(alice, bob).`, the generated code would look something like this:

```bash
declare -A parent_data=(
    ["alice:bob"]=1
)

parent() {
    local key="$1:$2"
    # Check if the key exists in the array
    [[ -n "${parent_data[$key]}" ]] && echo "$key"
}
```

### Rules as Functions and Pipelines

Prolog rules are compiled into Bash functions. 

*   **Non-recursive rules** become pipelines of commands that filter, join, and transform data streams.
*   **Recursive rules** (especially transitive closures) become the more complex BFS implementation discussed above, with `while` loops managing the queue and `grep` or similar tools finding the next set of relationships.

By compiling to these optimized structures, UnifyWeaver produces Bash code that is often far more efficient than a naive, direct translation of the Prolog logic would be.

## Next Steps

With an understanding of the architecture, we are now ready to get our hands dirty. In the next chapter, we will write our first UnifyWeaver program, defining a set of facts and rules, compiling them, and executing the resulting Bash script to see it all in action.
